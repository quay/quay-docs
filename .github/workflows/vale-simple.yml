name: Vale Linting

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  vale:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Vale and AsciiDoctor
        run: |
          # Download and install latest Vale
          VALE_VERSION="3.13.0"
          wget -q "https://github.com/errata-ai/vale/releases/download/v${VALE_VERSION}/vale_${VALE_VERSION}_Linux_64-bit.tar.gz"
          tar -xzf "vale_${VALE_VERSION}_Linux_64-bit.tar.gz" -C /usr/local/bin
          chmod +x /usr/local/bin/vale
          vale --version
          # Install AsciiDoctor (required by AsciiDocDITA package)
          sudo apt-get update -qq
          sudo apt-get install -y -qq ruby-full build-essential
          sudo gem install asciidoctor
          asciidoctor --version

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v40
        with:
          files: |
            **/*.adoc
            **/*.md

      - name: Verify Vale configuration
        working-directory: ${{ github.workspace }}
        run: |
          echo "Current directory: $(pwd)"
          echo "Checking if .vale.ini exists:"
          ls -la .vale.ini || echo ".vale.ini not found in root"
          echo "Checking Vale version:"
          vale --version
          echo "Checking Vale configuration..."
          vale ls-config || echo "Could not list config"
          echo "Syncing Vale styles (this downloads the package)..."
          vale sync || echo "Vale sync completed (may show warnings)"
          echo "Verifying styles were downloaded:"
          ls -la .vale/styles/ || echo "Styles directory not found"

      - name: Run Vale and post PR comments
        uses: actions/github-script@v7
        if: steps.changed-files.outputs.any_changed == 'true'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { execSync } = require('child_process');
            const fs = require('fs');
            // Note: 'core' is automatically available in github-script actions
            
            // Get pull request number
            const pullNumber = context.payload.pull_request?.number || context.issue.number;
            const commitId = context.payload.pull_request?.head?.sha;
            const isFork = context.payload.pull_request?.head?.repo?.full_name !== context.payload.pull_request?.base?.repo?.full_name;
            
            console.log(`PR Number: ${pullNumber}, Commit SHA: ${commitId}`);
            console.log(`Is Fork PR: ${isFork}`);
            console.log(`Repository: ${context.repo.owner}/${context.repo.repo}`);
            
            // Check if we can access the PR
            try {
              const prInfo = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pullNumber
              });
              console.log(`PR title: ${prInfo.data.title}`);
              console.log(`PR state: ${prInfo.data.state}`);
            } catch (error) {
              console.log(`Cannot access PR: ${error.message}`);
              if (isFork) {
                console.log('This is a fork PR. GITHUB_TOKEN has limited permissions on fork PRs.');
                console.log('Consider using a Personal Access Token (PAT) with repo scope for fork PRs.');
              }
            }
            
            // Get changed files
            const changedFiles = `${{ steps.changed-files.outputs.all_changed_files }}`.split(' ').filter(f => f && (f.endsWith('.adoc') || f.endsWith('.md')));
            
            if (changedFiles.length === 0) {
              console.log('No changed files to check');
              return;
            }
            
            console.log(`Checking files: ${changedFiles.join(', ')}`);
            
            // Verify Vale can see the config
            try {
              const configOutput = execSync('vale ls-config', { encoding: 'utf-8' });
              console.log('Vale configuration:');
              console.log(configOutput);
            } catch (error) {
              console.log('Warning: Could not get Vale config:', error.message);
            }
            
            // Run Vale and get JSON output
            // Ensure we're in the workspace directory
            process.chdir(process.env.GITHUB_WORKSPACE || '.');
            
            let valeResults = {};
            try {
              // First try to get output from stdout
              const valeOutput = execSync(`vale --output=JSON ${changedFiles.join(' ')}`, {
                encoding: 'utf-8',
                maxBuffer: 10 * 1024 * 1024,
                stdio: ['pipe', 'pipe', 'pipe'],
                cwd: process.env.GITHUB_WORKSPACE
              });
              console.log('Vale stdout:', valeOutput);
              if (valeOutput && valeOutput.trim()) {
                valeResults = JSON.parse(valeOutput);
              } else {
                console.log('Vale returned empty output - no issues found');
                return;
              }
            } catch (error) {
              // Vale returns non-zero exit code when issues are found, but still outputs JSON
              console.log('Vale exit code:', error.status);
              console.log('Vale stdout:', error.stdout);
              console.log('Vale stderr:', error.stderr);
              
              // Check stderr first for runtime errors, then stdout for linting results
              let output = error.stderr || error.stdout || '';
              
              // If stderr contains error info, check it first
              if (error.stderr && error.stderr.trim()) {
                try {
                  const stderrParsed = JSON.parse(error.stderr);
                  // Check if this is a runtime error (has Code like "E100")
                  if (stderrParsed.Code && stderrParsed.Code.startsWith('E')) {
                    console.log('Vale runtime error detected:', stderrParsed.Text);
                    console.log('This usually means a dependency is missing (e.g., asciidoctor)');
                    return;
                  }
                } catch (e) {
                  // stderr might not be JSON, continue to check stdout
                }
              }
              
              // Try to parse stdout as linting results
              output = error.stdout || '';
              try {
                if (output && output.trim()) {
                  const parsed = JSON.parse(output);
                  // Check if this is a runtime error object (has Code property)
                  if (parsed.Code && parsed.Code.startsWith('E')) {
                    console.log('Vale runtime error detected:', parsed.Text);
                    console.log('This usually means a dependency is missing (e.g., asciidoctor)');
                    return;
                  }
                  // Check if it's a single error object instead of file-based results
                  if (parsed.Code && !Array.isArray(parsed) && Object.keys(parsed).length <= 5) {
                    console.log('Vale runtime error detected:', parsed.Text || parsed.message);
                    return;
                  }
                  // Otherwise, it's actual linting results
                  valeResults = parsed;
                } else {
                  console.log('No Vale output to parse - this might mean no issues were found');
                  return;
                }
              } catch (parseError) {
                console.log('Could not parse Vale output as JSON');
                console.log('Raw output:', output);
                console.log('Parse error:', parseError.message);
                return;
              }
            }
            
            // Check if valeResults is empty or has no actual file results
            if (!valeResults || Object.keys(valeResults).length === 0) {
              console.log('No Vale issues found in changed files');
              return;
            }
            
            // Filter out error objects that aren't file paths
            const fileResults = {};
            for (const [key, value] of Object.entries(valeResults)) {
              // Skip if key looks like an error property (Path, Text, Code, etc.)
              if (['Path', 'Text', 'Code', 'Span', 'Line'].includes(key) && typeof value !== 'object') {
                continue;
              }
              // Only process if value is an array (alerts for a file)
              if (Array.isArray(value)) {
                fileResults[key] = value;
              }
            }
            
            console.log('Vale results:', JSON.stringify(fileResults, null, 2));
            console.log('Number of files with issues:', Object.keys(fileResults).length);
            
            if (Object.keys(fileResults).length === 0) {
              console.log('No files with linting issues found');
              return;
            }
            
            // Debug: List all files in the repo to verify paths
            try {
              const repoFiles = execSync('find . -name "*.adoc" -type f | head -20', { encoding: 'utf-8' });
              console.log('Sample .adoc files in repo:', repoFiles);
            } catch (e) {
              console.log('Could not list repo files');
            }
            
            // Post comments for each file with issues
            let commentCount = 0;
            let allComments = []; // Collect all comments for summary
            
            for (const [file, alerts] of Object.entries(fileResults)) {
              if (!alerts || alerts.length === 0) continue;
              
              console.log(`\n=== Processing file: ${file} ===`);
              console.log(`Alerts: ${alerts.length}`);
              
              // Ensure file path is relative to repo root (GitHub API requires relative paths)
              let filePath = file;
              const workspace = process.env.GITHUB_WORKSPACE || '.';
              if (filePath.startsWith(workspace)) {
                filePath = filePath.replace(workspace + '/', '');
              } else if (filePath.startsWith('/')) {
                // Absolute path, try to make it relative
                const parts = filePath.split('/');
                filePath = parts.slice(parts.length - 2).join('/'); // Get last 2 parts (e.g., modules/filename.adoc)
              }
              
              // Try to find the actual file path in the repo
              let actualFilePath = filePath;
              try {
                // Check if file exists as-is
                if (!fs.existsSync(filePath)) {
                  // Try to find it in the repo
                  const findResult = execSync(`find . -name "${filePath.split('/').pop()}" -type f | grep -v node_modules | head -1`, { encoding: 'utf-8' });
                  if (findResult.trim()) {
                    actualFilePath = findResult.trim().replace(/^\.\//, '');
                    console.log(`Found file at: ${actualFilePath} (was looking for: ${filePath})`);
                  }
                } else {
                  console.log(`File exists at: ${filePath}`);
                }
              } catch (e) {
                console.log(`Could not verify file path: ${e.message}`);
              }
              
              console.log(`Using file path: ${actualFilePath} (original: ${file})`);
              
              // Read file to get line content
              let fileContent = [];
              try {
                fileContent = fs.readFileSync(file, 'utf-8').split('\n');
              } catch (error) {
                console.log(`Could not read file ${file}: ${error.message}`);
                continue;
              }
              
              // Group alerts by line number
              const alertsByLine = {};
              alerts.forEach(alert => {
                const line = alert.Line || 1;
                if (!alertsByLine[line]) {
                  alertsByLine[line] = [];
                }
                alertsByLine[line].push(alert);
              });
              
              // Collect all comments for this file
              const fileComments = [];
              
              // Post comment for each line with issues
              for (const [lineNum, lineAlerts] of Object.entries(alertsByLine)) {
                const line = parseInt(lineNum);
                const severity = lineAlerts[0].Severity || 'warning';
                const check = lineAlerts[0].Check || '';
                
                const body = lineAlerts.map(alert => {
                  const message = alert.Message || '';
                  const link = alert.Link ? `\n\n[Learn more](${alert.Link})` : '';
                  return `**${alert.Severity || 'warning'}**: ${message}${link}`;
                }).join('\n\n---\n\n') + `\n\n*Rule: \`${check}\`*`;
                
                fileComments.push({
                  path: actualFilePath,
                  line: line,
                  body: body
                });
                
                // Also collect for summary comment
                allComments.push({
                  file: actualFilePath,
                  line: line,
                  message: lineAlerts[0].Message || '',
                  severity: severity
                });
              }
              
              // Post all comments for this file at once using createReview
              if (fileComments.length > 0) {
                try {
                  // Create a review with all comments
                  await github.rest.pulls.createReview({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pullNumber,
                    commit_id: commitId,
                    event: 'COMMENT',
                    comments: fileComments
                  });
                  commentCount += fileComments.length;
                  console.log(`Posted ${fileComments.length} comment(s) for ${file}`);
                } catch (error) {
                  console.log(`Error creating review for ${file}: ${error.message}`);
                  
                  // Fallback: try posting individual review comments
                  for (const comment of fileComments) {
                    try {
                      await github.rest.pulls.createReviewComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        pull_number: pullNumber,
                        commit_id: commitId,
                        path: comment.path,
                        line: comment.line,
                        body: comment.body
                      });
                      commentCount++;
                    } catch (reviewError) {
                      console.log(`Error posting review comment for ${comment.path}:${comment.line}: ${reviewError.message}`);
                      
                      // Final fallback: post as general PR comment
                      try {
                        const commentBody = `**File:** \`${comment.path}\` (line ${comment.line})\n\n${comment.body}`;
                        await github.rest.issues.createComment({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: pullNumber,
                          body: commentBody
                        });
                        commentCount++;
                        console.log(`Posted as general comment for ${comment.path}:${comment.line}`);
                      } catch (commentError) {
                        console.log(`Error posting general comment: ${commentError.message}`);
                      }
                    }
                  }
                }
              }
            }
            
            // If no inline comments were posted, use annotations for fork PRs or create summary comment
            if (commentCount === 0 && allComments.length > 0) {
              console.log('No inline comments were posted...');
              
              // For fork PRs, use workflow annotations (they show up in the Checks tab)
              if (isFork) {
                console.log('This is a fork PR. Using workflow annotations instead of comments...');
                
                // Post annotations for each issue (these show up in the Checks tab)
                for (const comment of allComments) {
                  const annotationLevel = comment.severity === 'error' ? 'error' : 'warning';
                  if (annotationLevel === 'error') {
                    core.error(comment.message, {
                      file: comment.file,
                      startLine: comment.line,
                      endLine: comment.line,
                      title: `Vale: ${comment.severity}`
                    });
                  } else {
                    core.warning(comment.message, {
                      file: comment.file,
                      startLine: comment.line,
                      endLine: comment.line,
                      title: `Vale: ${comment.severity}`
                    });
                  }
                }
                
                // Also create a summary in the workflow run
                let summary = `## ⚠️ Vale Linting Issues Found\n\n`;
                summary += `Found **${allComments.length} issue(s)** in **${Object.keys(fileResults).length} file(s)**:\n\n`;
                
                const byFile = {};
                for (const comment of allComments) {
                  if (!byFile[comment.file]) {
                    byFile[comment.file] = [];
                  }
                  byFile[comment.file].push(comment);
                }
                
                for (const [file, fileComments] of Object.entries(byFile)) {
                  summary += `### \`${file}\`\n\n`;
                  for (const comment of fileComments) {
                    summary += `- **Line ${comment.line}** (${comment.severity}): ${comment.message}\n`;
                  }
                  summary += `\n`;
                }
                
                summary += `---\n*Note: This is a fork PR. Comments cannot be posted, but issues are shown in the annotations above.*`;
                
                await core.summary.addRaw(summary).write();
                
                core.setFailed(`Vale found ${allComments.length} issue(s). See annotations in the Checks tab.`);
                return;
              }
              
              try {
                let summaryBody = `## ⚠️ Vale Linting Issues Found\n\n`;
                summaryBody += `Found **${allComments.length} issue(s)** in **${Object.keys(fileResults).length} file(s)**:\n\n`;
                
                // Group by file
                const byFile = {};
                for (const comment of allComments) {
                  if (!byFile[comment.file]) {
                    byFile[comment.file] = [];
                  }
                  byFile[comment.file].push(comment);
                }
                
                for (const [file, fileComments] of Object.entries(byFile)) {
                  summaryBody += `### \`${file}\`\n\n`;
                  for (const comment of fileComments) {
                    summaryBody += `- **Line ${comment.line}** (${comment.severity}): ${comment.message}\n`;
                  }
                  summaryBody += `\n`;
                }
                
                summaryBody += `---\n*Please review and fix these issues before merging.*`;
                
                const commentResult = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pullNumber,
                  body: summaryBody
                });
                console.log(`Posted summary comment on PR: ${commentResult.data.html_url}`);
              } catch (summaryError) {
                console.log(`Error posting summary comment: ${summaryError.message}`);
                console.log(`Status: ${summaryError.status}`);
                
                // Fallback: use workflow annotations if comments fail
                console.log('Falling back to workflow annotations...');
                for (const comment of allComments) {
                  if (comment.severity === 'error') {
                    core.error(comment.message, {
                      file: comment.file,
                      startLine: comment.line,
                      endLine: comment.line,
                      title: `Vale: ${comment.severity}`
                    });
                  } else {
                    core.warning(comment.message, {
                      file: comment.file,
                      startLine: comment.line,
                      endLine: comment.line,
                      title: `Vale: ${comment.severity}`
                    });
                  }
                }
                
                // Create workflow summary
                let summary = `## ⚠️ Vale Linting Issues Found\n\n`;
                summary += `Found **${allComments.length} issue(s)** in **${Object.keys(fileResults).length} file(s)**:\n\n`;
                
                const byFile = {};
                for (const comment of allComments) {
                  if (!byFile[comment.file]) {
                    byFile[comment.file] = [];
                  }
                  byFile[comment.file].push(comment);
                }
                
                for (const [file, fileComments] of Object.entries(byFile)) {
                  summary += `### \`${file}\`\n\n`;
                  for (const comment of fileComments) {
                    summary += `- **Line ${comment.line}** (${comment.severity}): ${comment.message}\n`;
                  }
                  summary += `\n`;
                }
                
                summary += `---\n*Issues are shown in the annotations above. Comments could not be posted due to permissions.*`;
                await core.summary.addRaw(summary).write();
                
                if (summaryError.status === 403) {
                  console.log('403 Forbidden - Check repository permissions and branch protection settings');
                  core.setFailed(`Vale found ${allComments.length} issue(s). See annotations in the Checks tab.`);
                } else {
                  console.log(`Error details:`, JSON.stringify(summaryError.response?.data || summaryError.message, null, 2));
                  core.setFailed(`Vale found ${allComments.length} issue(s). See annotations in the Checks tab.`);
                }
              }
            }
            
            console.log(`\n=== Summary ===`);
            console.log(`Posted ${commentCount} inline comment(s) on the PR`);
            console.log(`Total issues found: ${allComments.length}`);
            
            // Fail the workflow if issues were found but no comments were posted
            if (commentCount === 0 && allComments.length > 0) {
              const errorMsg = `Vale found ${allComments.length} issue(s) but could not post comments. Check workflow logs for details.`;
              console.error(errorMsg);
              core.setFailed(errorMsg);
              
              // Also output the issues as workflow output for visibility
              core.setOutput('vale_issues', JSON.stringify(allComments));
              core.setOutput('vale_issues_count', allComments.length.toString());
            } else if (allComments.length > 0) {
              // Successfully posted comments, but still mark as having issues
              core.setOutput('vale_issues', JSON.stringify(allComments));
              core.setOutput('vale_issues_count', allComments.length.toString());
            }


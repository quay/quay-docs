name: Vale PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - '**.adoc'
      - '**.md'
      - '.vale.ini'
      - '.vale/**'

permissions:
  contents: read
  pull-requests: write

jobs:
  vale-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history needed for diff

      - name: Install Vale
        run: |
          # Download and install latest Vale
          VALE_VERSION="3.13.0"
          wget -q "https://github.com/errata-ai/vale/releases/download/v${VALE_VERSION}/vale_${VALE_VERSION}_Linux_64-bit.tar.gz"
          tar -xzf "vale_${VALE_VERSION}_Linux_64-bit.tar.gz" -C /usr/local/bin
          chmod +x /usr/local/bin/vale
          vale --version

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v46
        with:
          files: |
            **/*.adoc
            **/*.md

      - name: Run Vale on changed files
        id: vale
        continue-on-error: true
        run: |
          # Create a temporary file to store Vale output
          VALE_OUTPUT=$(mktemp)
          
          # Get list of changed files
          CHANGED_FILES="${{ steps.changed-files.outputs.all_changed_files }}"
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No changed files to check"
            exit 0
          fi
          
          # Run Vale on changed files and capture output
          vale --output=JSON $CHANGED_FILES > "$VALE_OUTPUT" 2>&1 || true
          
          # Save output for next step
          echo "vale_output<<EOF" >> $GITHUB_OUTPUT
          cat "$VALE_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Also save as artifact for debugging
          echo "$VALE_OUTPUT" > vale_output_path.txt

      - name: Post Vale results as PR comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Get changed files
            const changedFiles = `${{ steps.changed-files.outputs.all_changed_files }}`.split(' ').filter(f => f);
            
            if (changedFiles.length === 0) {
              console.log('No changed files to check');
              return;
            }
            
            // Run Vale and parse JSON output
            let results = {};
            try {
              const valeOutput = execSync(`vale --output=JSON ${changedFiles.join(' ')}`, {
                encoding: 'utf-8',
                maxBuffer: 10 * 1024 * 1024
              });
              results = JSON.parse(valeOutput);
            } catch (error) {
              // Vale returns non-zero exit code when issues are found, but still outputs JSON
              const output = error.stdout || error.message;
              try {
                results = JSON.parse(output);
              } catch (parseError) {
                console.log('No Vale issues found or error parsing output');
                console.log('Vale output:', output);
                return;
              }
            }
              
              // Post comments for each file with issues
              let commentCount = 0;
              for (const [file, alerts] of Object.entries(results)) {
                if (!alerts || alerts.length === 0) continue;
                
                // Read file to get line content
                let fileContent = [];
                try {
                  fileContent = fs.readFileSync(file, 'utf-8').split('\n');
                } catch (error) {
                  console.log(`Could not read file ${file}: ${error.message}`);
                  continue;
                }
                
                // Group alerts by line
                const alertsByLine = {};
                alerts.forEach(alert => {
                  const line = alert.Line || 1;
                  if (!alertsByLine[line]) {
                    alertsByLine[line] = [];
                  }
                  alertsByLine[line].push(alert);
                });
                
                // Post comment for each line with issues
                for (const [lineNum, lineAlerts] of Object.entries(alertsByLine)) {
                  const line = parseInt(lineNum);
                  const severity = lineAlerts[0].Severity || 'warning';
                  const check = lineAlerts[0].Check || '';
                  
                  const body = lineAlerts.map(alert => {
                    const message = alert.Message || '';
                    const link = alert.Link ? `\n\n[Learn more](${alert.Link})` : '';
                    return `**${alert.Severity || 'warning'}**: ${message}${link}`;
                  }).join('\n\n---\n\n') + `\n\n*Rule: \`${check}\`*`;
                  
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: context.issue.number,
                      commit_id: context.payload.pull_request.head.sha,
                      path: file,
                      line: line,
                      body: body
                    });
                    commentCount++;
                  } catch (error) {
                    console.log(`Error posting comment for ${file}:${line}: ${error.message}`);
                  }
                }
              }
              console.log(`Posted ${commentCount} comment(s) on the PR`);
            } catch (error) {
              console.log('Error running Vale check:');
              console.log(error.message);
            }


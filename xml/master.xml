<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE book [
<!ENTITY % BOOK_ENTITIES SYSTEM "master.ent">
%BOOK_ENTITIES;
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<book version="5.0" xml:lang="en-US" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
	<?asciidoc-toc ?><?asciidoc-numbered ?>
	<info>
		<title>Use Red Hat Quay</title>
		<subtitle>Use Red Hat Quay</subtitle>
		 <date>2021-09-21</date>
		<productname>Red Hat Quay</productname>
		<productnumber>3.6</productnumber>
		<abstract>
			<para>
				Learn to use Red Hat Quay
			</para>
		</abstract>
		<xi:include href="Author_Group.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
		<xi:include href="Common_Content/Legal_Notice.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
	</info>
	<preface>
		<title>Preface</title>
		<simpara>
			Red Hat Quay container image registries let you store container images in a central location. As a regular user of a Red Hat Quay registry, you can create repositories to organize your images and selectively add read (pull) and write (push) access to the repositories you control. A user with administrative privileges can perform a broader set of tasks, such as the ability to add users and control default settings.
		</simpara>
		<simpara>
			This guide assumes you have a Red Hat Quay deployed and are ready to start setting it up and using it.
		</simpara>
	</preface>
	<chapter xml:id="user-org-intro">
		<title>Users and organizations in Red Hat Quay</title>
		<simpara>
			Before you begin creating repositories to hold your container images in Red Hat Quay, you should consider how you want to organize those repositories. Every repository in a Red Hat Quay instance must be associated with either an Organization or a User.
		</simpara>
		<section xml:id="tenancy-model">
			<title>Red Hat Quay tenancy model</title>
			<simpara>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="images/178_Quay_architecture_0821_tenancy_model.png" format="PNG" />
					</imageobject>
					<textobject>
						<phrase>Quay tenancy model</phrase>
					</textobject>
				</inlinemediaobject>
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						<emphasis role="strong">Organizations</emphasis> provide a way of sharing repositories under a common namespace that does not belong to a single user, but rather to many users in a shared setting (such as a company).
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">Teams</emphasis> provide a way for an organization to delegate permissions (both global and on specific repositories) to sets or groups of users
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">Users</emphasis> can log in to a registry through the Quay web UI or a client (such as <literal>podman login</literal>). Each users automatically gets a user namespace, for example, <literal>quay-server.example.com/user/&lt;username&gt;</literal>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">Super users</emphasis> have enhanced access and privileges via the Super User Admin Panel in the user interface and through Super User API calls that are not visible or accessible to normal users
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">Robot accounts</emphasis> provide automated access to repositories for non-human users such as pipeline tools and are similar in nature to OpenShift service accounts. Permissions can be granted to a robot account in a repository by adding that account like any other user or team.
					</simpara>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="user-create">
			<title>Creating user accounts</title>
			<simpara>
				To create a new user for your Red Hat Quay instance:
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						Log in to Red Hat Quay as the superuser (quay by default).
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select your account name from the upper right corner of the home page and choose Super User Admin Panel.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select the Users icon from the left column.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select the Create User button.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Enter the new user’s Username and Email address, then select the Create User button.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Back on the Users page, select the Options icon to the right of the new Username. A drop-down menu appears, as shown in the following figure:
					</simpara>
					<simpara>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="images/user-options.png" format="PNG" />
							</imageobject>
							<textobject>
								<phrase>Select Options drop-down to change user passwords</phrase>
							</textobject>
						</inlinemediaobject>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Choose Change Password from the menu.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Add the new password and verify it, then select the Change User Password button.
					</simpara>
				</listitem>
			</orderedlist>
			<simpara>
				The new user can now use that username and password to log in via the web ui or through some container client.
			</simpara>
		</section>
		<section xml:id="org-create">
			<title>Creating organization accounts</title>
			<simpara>
				Any user can create their own organization to share repositories of container images. To create a new organization:
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						While logged in as any user, select the plus sign (+) from the upper right corner of the home page and choose New Organization.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Type the name of the organization. The name must be alphanumeric, all lower case, and between 2 and 255 characters long
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select Create Organization. The new organization appears, ready for you to begin adding repositories, teams, robot accounts and other features from icons on the left column. The following figure shows an example of the new organization’s page with the settings tab selected.
					</simpara>
					<simpara>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="images/new-org.png" format="PNG" />
							</imageobject>
							<textobject>
								<phrase>Create new repos and teams from an Organization page</phrase>
							</textobject>
						</inlinemediaobject>
					</simpara>
				</listitem>
			</orderedlist>
		</section>
	</chapter>
	<chapter xml:id="use-quay-create-repo">
		<title>Creating a repository</title>
		<simpara>
			A repository provides a central location for storing a related set of container images. There are two ways to create a repository in Red Hat Quay: via a push (from <literal>docker</literal> or <literal>podman</literal>) and via the Red Hat Quay UI. These are essentially the same, whether you are using Quay.io or your own instance of Red Hat Quay.
		</simpara>
		<section xml:id="creating-an-image-repository-via-the-ui">
			<title>Creating an image repository via the UI</title>
			<simpara>
				To create a repository in the Red Hat Quay UI under a user account: . Log in to the user account through the web UI. . Click the + icon in the top right of the header on the home page (or other page related to the user) and choose New Repository, as shown in the following figure:
			</simpara>
			<simpara>
				+ 
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="images/repo-create.png" format="PNG" />
					</imageobject>
					<textobject>
						<phrase>Create a new repository for a user.</phrase>
					</textobject>
				</inlinemediaobject>
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						On the Create New Repository page that appears
					</simpara>
					<itemizedlist>
						<listitem>
							<simpara>
								Add the new repository name to your user name
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Click Repository Description and type a description of the repository
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								In Repository Visibility, select whether you want the repository to be public or private
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Click the Create Repository button.
							</simpara>
						</listitem>
					</itemizedlist>
				</listitem>
			</orderedlist>
			<simpara>
				The new repository is created, starting out empty. A docker pull command you could use to pull an image from this repository (minus the image name) appears on the screen.
			</simpara>
			<simpara>
				To create a repository in the Red Hat Quay UI under an organization:
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						Log in as a user that has Admin or Write permission to the organization.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						From the Repositories view, select the organization name from the right column under Users and Organizations. The page for the organization appears, similar to the page shown in Figure 2.x:
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Click +Create New Repository in the upper-right part of the page.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						On the Create New Repository page that appears:
					</simpara>
					<itemizedlist>
						<listitem>
							<simpara>
								Add the new repository name to the organization name
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Click Repository Description and type a description of the repository
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								In Repository Visibility, select whether you want the repository to be public or private
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Click the Create Repository button.
							</simpara>
						</listitem>
					</itemizedlist>
				</listitem>
			</orderedlist>
			<simpara>
				The new repository is created, starting out empty. A docker pull command you could use to pull an image from this repository (minus the image name) appears on the screen.
			</simpara>
		</section>
		<section xml:id="creating-an-image-repository-via-docker">
			<title>Creating an image repository via docker or podman</title>
			<simpara>
				Assuming you have the proper credentials, pushing an image to a repository that does not yet exist in your Red Hat Quay instance will create that repository as it pushes the image to that repository. Either the <literal>docker</literal> or <literal>podman</literal> commands will work for these examples.
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						Tag the image: With an image available from <literal>docker</literal> or <literal>podman</literal> on your local system, tag that image with the new repository name and image name. Here are examples for pushing images to Quay.io or your own Red Hat Quay setup (for example, reg.example.com). For the examples, replace namespace with your Red Hat Quay user name or organization and repo_name with the name of the repository you want to create:
					</simpara>
					
<screen># sudo podman tag myubi-minimal quay.io/namespace/repo_name
# sudo podman tag myubi-standard reg.example.com/namespace/repo_name</screen>
				</listitem>
				<listitem>
					<simpara>
						Push to the appropriate registry. For example:
					</simpara>
					
<screen># sudo podman push quay.io/namespace/repo_name
# sudo podman push reg.example.com/namespace/repo_name</screen>
				</listitem>
			</orderedlist>
			<note>
				<simpara>
					To create an application repository, follow the same procedure you did for creating a container image repository.
				</simpara>
			</note>
		</section>
	</chapter>
	<chapter xml:id="use-quay-manage-repo">
		<title>Managing access to repositories</title>
		<simpara>
			As a Red Hat Quay user, you can create your own repositories and make them accessible to other users on your Red Hat Quay instance. As an alternative, you can create organizations to allow access to repositories based on teams. In both user and organization repositories, you can allow access to those repositories by creating credentials associated with robot accounts. Robot accounts make it easy for a variety of container clients (such as docker or podman) to access your repos, without requiring that the client have a Red Hat Quay user account.
		</simpara>
		<section xml:id="allow-access-user-repo">
			<title>Allowing access to user repositories</title>
			<simpara>
				When you create a repository in a user namespace, you can add access to that repository to user accounts or through robot accounts.
			</simpara>
			<section xml:id="allow-user-access-user-repo">
				<title>Allowing user access to a user repository</title>
				<simpara>
					To allow access to a repository associated with a user account, do the following:
				</simpara>
				<orderedlist numeration="arabic">
					<listitem>
						<simpara>
							Log into your Red Hat Quay user account.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Select a repository under your user namespace to which you want to share access.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Select the Settings icon from the left column.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Type the name of the user to which you want to grant access to your repository. The user name should appear as you type, as shown in the following figure:
						</simpara>
						<simpara>
							<inlinemediaobject>
								<imageobject>
									<imagedata fileref="images/grant-user-access.png" format="PNG" />
								</imageobject>
								<textobject>
									<phrase>Grant user access to a user repository</phrase>
								</textobject>
							</inlinemediaobject>
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							In the permissions box, select one of the following:
						</simpara>
						<itemizedlist>
							<listitem>
								<simpara>
									Read - Allows the user to view the repository and pull from it.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									Write - Allows the user to view the repository, as well as pull images from or push images to the repository.
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									Admin - Allows all administrative settings to the repository, as well as all Read and Write permissions.
								</simpara>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<simpara>
							Select the Add Permission button. The user now has the assigned permission.
						</simpara>
					</listitem>
				</orderedlist>
				<simpara>
					To remove the user permissions to the repository, select the Options icon to the right of the user entry, then select Delete Permission.
				</simpara>
			</section>
		</section>
		<section xml:id="allow-robot-access-user-repo">
			<title>Allowing robot access to a user repository</title>
			<simpara>
				Robot accounts are used to set up automated access to the repositories in your Red Hat Quay registry. They are similar to OpenShift service accounts. When you set up a robot account, you:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						Generate credentials that are associated with the robot account
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Identify repositories and images that the robot can push images to or pull images from
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Copy and paste generated credentials to use with different container clients (such as Docker, podman, Kubernetes, Mesos and others) to access each defined repository
					</simpara>
				</listitem>
			</itemizedlist>
			<simpara>
				Keep in mind that each robot account is limited to a single user namespace or organization. So, for example, the robot could provide access to all repositories accessible to a user jsmith, but not to any that are not in the user’s list of repositories.
			</simpara>
			<simpara>
				The following procedure steps you through setting up a robot account to allow access to your repositories.
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						Select Robot icon: From the Repositories view, select the Robot icon from the left column.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Create Robot account: Select the Create Robot Account button.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Set Robot name: Enter the name and description, then select the Create robot account button. The robot name becomes a combination of your user name, plus the robot name you set (for example, jsmith+myrobot)
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Add permission to the robot account: From the Add permissions screen for the robot account, define the repositories you want the robot to access as follows:
					</simpara>
					<itemizedlist>
						<listitem>
							<simpara>
								Put a check mark next to each repository the robot can access
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								For each repository, select one of the following, and click Add permissions:
							</simpara>
							<itemizedlist>
								<listitem>
									<simpara>
										None - Robot has no permission to the repository
									</simpara>
								</listitem>
								<listitem>
									<simpara>
										Read - Robot can view and pull from the repository
									</simpara>
								</listitem>
								<listitem>
									<simpara>
										Write - Robot can read (pull) from and write (push) to the repository
									</simpara>
								</listitem>
								<listitem>
									<simpara>
										Admin - Full access to pull from and push to the repository, plus the ability to do administrative tasks associated with the repository
									</simpara>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<simpara>
								Select the Add permissions button to apply the settings
							</simpara>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<simpara>
						Get credentials to access repositories via the robot: Back on the Robot Accounts page, select the Robot account name to see credential information for that robot.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Get the token: Select Robot Token, as shown in the following figure, to see the token that was generated for the robot. If you want to reset the token, select Regenerate Token.
					</simpara>
					<informalexample>
					<simpara>
						It is important to understand that regenerating a token makes any previous tokens for this robot invalid.
					</simpara>
					</informalexample>
					<simpara>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="images/robot-gen-token.png" format="PNG" />
							</imageobject>
							<textobject>
								<phrase>Select Options drop-down to change user passwords</phrase>
							</textobject>
						</inlinemediaobject>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Get credentials: Once you are satisfied with the generated token, get the resulting credentials in the following ways:
					</simpara>
					<itemizedlist>
						<listitem>
							<simpara>
								Kubernetes Secret: Select this to download credentials in the form of a Kubernetes pull secret yaml file.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								rkt Configuration: Select this to download credentials for the rkt container runtime in the form of a json file.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Docker Login: Select this to copy a full <literal>docker login</literal> command line that includes the credentials.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Docker Configuration: Select this to download a file to use as a Docker config.json file, to permanently store the credentials on your client system.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Mesos Credentials: Select this to download a tarball that provides the credentials that can be identified in the uris field of a Mesos configuration file.
							</simpara>
						</listitem>
					</itemizedlist>
				</listitem>
			</orderedlist>
		</section>
		<section xml:id="allow-access-org-repo">
			<title>Allowing access to organization repositories</title>
			<simpara>
				Once you have created an organization, you can associate a set of repositories directly to that organization. To add access to the repositories in that organization, you can add Teams (sets of users with the same permissions) and individual users. Essentially, an organization has the same ability to create repositories and robot accounts as a user does, but an organization is intended to set up shared repositories through groups of users (in teams or individually).
			</simpara>
			<simpara>
				Other things to know about organizations:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						You cannot have an organization in another organization. To subdivide an organization, you use teams.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Organizations can’t contain users directly. You must first add a team, then add one or more users to each team.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Teams can be set up in organizations as just members who use the repos and associated images or as administrators with special privileges for managing the organization
					</simpara>
				</listitem>
			</itemizedlist>
			<section xml:id="allow-team-access-org-repo">
				<title>Adding a Team to an organization</title>
				<simpara>
					When you create a team for your organization you can select the team name, choose which repositories to make available to the team, and decide the level of access to the team.
				</simpara>
				<orderedlist numeration="arabic">
					<listitem>
						<simpara>
							From the Organization view, select the Teams and Membership icon from the left column. You will see that an owners Team exists with Admin privilege for the user who created the Organization.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Select Create New Team. You are prompted for the new team name to be associated with the organization. Type the team name, which must start with a lowercase letter, with the rest of the team name as any combination of lowercase letters and numbers (no capitals or special characters allowed).
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Select the Create team button. The Add permissions window appears, displaying a list of repositories in the organization.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Check each repository you want the team to be able to access. Then select one of the following permissions for each:
						</simpara>
						<itemizedlist>
							<listitem>
								<simpara>
									Read - Team members are able to view and pull images
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									Write - Team members can view, pull, and push images
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									Admin - Team members have full read/write privilege, plus the ability to do administrative tasks related to the repository
								</simpara>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<simpara>
							Select Add permissions to save the repository permissions for the team.
						</simpara>
					</listitem>
				</orderedlist>
			</section>
			<section xml:id="set-team-role">
				<title>Setting a Team role</title>
				<simpara>
					After you have added a team, you can set the role of that team within the organization. From the Teams and Membership screen within the organization, select the TEAM ROLE drop-down menu, as shown in the following figure:
				</simpara>
				<simpara>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="images/set-team-role.png" format="PNG" />
						</imageobject>
						<textobject>
							<phrase>Set the role that a team has within an organization</phrase>
						</textobject>
					</inlinemediaobject>
				</simpara>
				<simpara>
					For the selected team, choose one of the following roles:
				</simpara>
				<itemizedlist>
					<listitem>
						<simpara>
							Member - Inherits all permissions set for the team
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Creator - All member permissions, plus the ability to create new repositories
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Admin - Full administrative access to the organization, including the ability to create teams, add members, and set permissions.
						</simpara>
					</listitem>
				</itemizedlist>
			</section>
			<section xml:id="add-users-to-team">
				<title>Adding users to a Team</title>
				<simpara>
					As someone with Admin privilege to an organization, you can add users and robots to a team. When you add a user, it sends an email to that user. The user remains pending until that user accepts the invitation.
				</simpara>
				<simpara>
					To add users or robots to a team, start from the organization’s screen and do the following:
				</simpara>
				<orderedlist numeration="arabic">
					<listitem>
						<simpara>
							Select the team you want to add users or robots to.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							In the Team Members box, type one of the following:
						</simpara>
						<itemizedlist>
							<listitem>
								<simpara>
									A username from an account on the Red Hat Quay registry
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									The email address for a user account on the registry
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									The name of a robot account. The name must be in the form of orgname+robotname
								</simpara>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<simpara>
							In the case of the robot account, it is immediately added to the team. For a user account, an invitation to join is mailed to the user. Until the user accepts that invitation, the user remains in the INVITED TO JOIN state.
						</simpara>
					</listitem>
				</orderedlist>
				<simpara>
					Next, the user accepts the email invitation to join the team. The next time the user logs in to the Red Hat Quay instance, the user moves from the INVITED TO JOIN list to the MEMBERS list for the organization.
				</simpara>
			</section>
		</section>
	</chapter>
	<chapter remap="_working_with_tags" xml:id="working_with_tags">
		<title>Working with tags</title>
		<simpara>
			Tags provide a way to identify the version of an image, as well as offering a means of naming the same image in different ways. Besides an image’s version, an image tag can identify its uses (such as devel, testing, or prod) or the fact that it is the most recent version (latest).
		</simpara>
		<simpara>
			From the <emphasis role="strong">Tags</emphasis> tab of an image repository, you can view, modify, add, move, delete, and see the history of tags. You also can fetch command-lines you can use to download (pull) a specific image (based on its name and tag) using different commands.
		</simpara>
		<section xml:id="viewing-and-modifying-tags">
			<title>Viewing and modifying tags</title>
			<simpara>
				The tags of a repository can be viewed and modified in the tags panel of the repository page, found by clicking on the <emphasis role="strong">Tags</emphasis> tab. 
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="images/tag-operations.png" format="PNG" />
					</imageobject>
					<textobject>
						<phrase>View and modify tags from your repository</phrase>
					</textobject>
				</inlinemediaobject>
			</simpara>
			<section xml:id="adding-a-new-tag-to-a-tagged-image">
				<title>Adding a new tag to a tagged image</title>
				<simpara>
					A new tag can be added to a tagged image by clicking on the gear icon next to the tag and choosing <literal>Add New Tag</literal>. Red Hat Quay will confirm the addition of the new tag to the image.
				</simpara>
			</section>
			<section xml:id="moving-a-tag">
				<title>Moving a tag</title>
				<simpara>
					Moving a tag to a different image is accomplished by performing the same operation as adding a new tag, but giving an existing tag name. Red Hat Quay will confirm that you want the tag moved, rather than added.
				</simpara>
			</section>
			<section xml:id="deleting-a-tag">
				<title>Deleting a tag</title>
				<simpara>
					A specific tag and all its images can be deleted by clicking on the tag’s gear icon and choosing <literal>Delete Tag</literal>. This will delete the tag and any images unique to it. Images will not be deleted until no tag references them either directly or indirectly through a parent child relationship.
				</simpara>
			</section>
			<section xml:id="viewing-tag-history-and-going-back-in-time">
				<title>Viewing tag history and going back in time</title>
				<section xml:id="viewing-tag-history">
					<title>Viewing tag history</title>
					<simpara>
						To view the image history for a tag, click on the <literal>View Tags History</literal> menu item located under the <literal>Actions</literal> menu. The page shown will display each image to which the tag pointed in the past and when it pointed to that image.
					</simpara>
				</section>
				<section xml:id="going-back-in-time">
					<title>Going back in time</title>
					<simpara>
						To revert the tag to a previous image, find the history line where your desired image was overwritten, and click on the Restore link.
					</simpara>
				</section>
			</section>
			<section xml:id="fetching-images-and-tags">
				<title>Fetching an image by tag or digest</title>
				<simpara>
					From the <emphasis role="strong">Tags</emphasis> tab, you can view different ways of pulling images from the clients that are ready to use those images.
				</simpara>
				<orderedlist numeration="arabic">
					<listitem>
						<simpara>
							Select a particular repository/image
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Select Tags in the left column
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Select the Fetch Tag icon for a particular image/tag combination
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							When the Fetch Tag pop-up appears, select the Image format box to see a drop-down menu that shows different ways that are available to pull the image. The selections offer full command lines for pulling a specific container image to the local system:
						</simpara>
					</listitem>
				</orderedlist>
				<simpara>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="images/image-fetch.png" format="PNG" />
						</imageobject>
						<textobject>
							<phrase>Get commands for fetching images in different ways</phrase>
						</textobject>
					</inlinemediaobject>
				</simpara>
				<simpara>
					You can select to pull a regular of an image by tag name or by digest name using the <emphasis role="strong">docker</emphasis> command. . Choose the type of pull you want, then select <literal>Copy Command</literal>. The full command-line is copied into your clipboard. These two commands show a <emphasis role="strong">docker pull</emphasis> by tag and by digest:
				</simpara>
				
<screen>docker pull quay.io/cnegus/whatever:latest
docker pull quay.io/cnegus/whatever@sha256:e02231a6aa8ba7f5da3859a359f99d77e371cb47e643ce78e101958782581fb9</screen>
				<simpara>
					Paste the command into a command-line shell on a system that has the <emphasis role="strong">docker</emphasis> command and service available, and press Enter. At this point, the container image is ready to run on your local system.
				</simpara>
				<simpara>
					On RHEL and Fedora systems, you can substitute <emphasis role="strong">podman</emphasis> for <emphasis role="strong">docker</emphasis> to pull and run the selected image.
				</simpara>
			</section>
		</section>
		<section xml:id="tag-expiration">
			<title>Tag Expiration</title>
			<simpara>
				Images can be set to expire from a Red Hat Quay repository at a chosen date and time using a feature called <literal>tag expiration</literal>. Here are a few things to know about about tag expiration:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						When a tag expires, the tag is deleted from the repository. If it is the last tag for a specific image, the image is set to be deleted.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Expiration is set on a per-tag basis, not for a repository on the whole.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						When a tag expires or is deleted, it is not immediately removed from the registry. The value of Time Machine (in User settings) defines when the deleted tag is actually removed and garbage collected. By default, that value is 14 days. Up until that time, a tag can be repointed to an expired or deleted image.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						The Red Hat Quay superuser has no special privilege related to deleting expired images from user repositories. There is no central mechanism for the superuser to gather information and act on user repositories. It is up to the owners of each repository to manage expiration and ultimate deletion of their images.
					</simpara>
				</listitem>
			</itemizedlist>
			<simpara>
				Tag expiration can be set in different ways:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						By setting the <literal>quay.expires-after=</literal> LABEL in the Dockerfile when the image is created. This sets a time to expire from when the image is built.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						By choosing the expiration date from the EXPIRES column for the repository tag and selecting a specific date and time to expire.
					</simpara>
				</listitem>
			</itemizedlist>
			<simpara>
				The following figure shows the Options entry for changing tag expiration and the EXPIRES field for when the tag expires. Hover over the EXPIRES field to see the expiration date and time that is currently set.
			</simpara>
			<simpara>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="images/tag-expires-ui.png" format="PNG" />
					</imageobject>
					<textobject>
						<phrase>Change tag expiration under the Options icon or from the EXPIRES column</phrase>
					</textobject>
				</inlinemediaobject>
			</simpara>
			<section remap="_setting_tag_expiration_from_a_dockerfile" xml:id="setting_tag_expiration_from_a_dockerfile">
				<title>Setting tag expiration from a Dockerfile</title>
				<simpara>
					Adding a label like <literal>quay.expires-after=20h</literal> via the Dockerfile LABEL command will cause a tag to automatically expire after the time indicated. The time values could be something like <literal>1h</literal>, <literal>2d</literal>, <literal>3w</literal> for hours, days, and weeks, respectively, from the time the image is built.
				</simpara>
			</section>
			<section remap="_setting_tag_expiration_from_the_repository" xml:id="setting_tag_expiration_from_the_repository">
				<title>Setting tag expiration from the repository</title>
				<simpara>
					On the Repository Tag page there is a UI column titled <emphasis role="strong">EXPIRES</emphasis> that indicates when a tag will expire. Users can set this by clicking on the time that it will expire or by clicking the Settings button (gear icon) on the right and choosing <literal>Change Expiration</literal>.
				</simpara>
				<simpara>
					Choose the date and time when prompted and select <literal>Change Expiration</literal>. The tag will be set to be deleted from the repository when the expiration time is reached.
				</simpara>
			</section>
		</section>
		<section xml:id="security-scanning">
			<title>Security scanning</title>
			<simpara>
				By clicking the on the vulnerability or fixable count next to a tab you can jump into the security scanning information for that tag. There you can find which CVEs your image is susceptible to, and what remediation options you may have available.
			</simpara>
			<simpara>
				Keep in mind that image scanning only lists vulnerabilities found by the Clair image scanner. What each user does about the vulnerabilities that are uncovered is completely up to that user. The Red Hat Quay superuser does not act on those vulnerabilities found.
			</simpara>
		</section>
	</chapter>
	<chapter xml:id="use-quay-view-export-logs">
		<title>Viewing and exporting logs</title>
		<simpara>
			Activity logs are gathered for all repositories and namespaces (users and organizations) in Red Hat Quay. There are multiple ways of accessing log files, including:
		</simpara>
		<itemizedlist>
			<listitem>
				<simpara>
					Viewing logs through the web UI
				</simpara>
			</listitem>
			<listitem>
				<simpara>
					Exporting logs so they can be saved externally.
				</simpara>
			</listitem>
			<listitem>
				<simpara>
					Accessing log entries via the API
				</simpara>
			</listitem>
		</itemizedlist>
		<simpara>
			To access logs, you must have Admin privilege to the selected repository or namespace.
		</simpara>
		<note>
			<simpara>
				A maximum of 100 log results are available at a time via the API. To gather more results that that, you must use the log exporter feature described in this chapter.
			</simpara>
		</note>
		<section xml:id="use-quay-view-logs">
			<title>Viewing logs</title>
			<simpara>
				To view log entries for a repository or namespace from the web UI, do the following:
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						Select a repository or namespace (organization or user) for which you have Admin privileges.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select the Usage Logs icon from the left column. A Usage Logs screen appears, like the one shown in the following figure:
					</simpara>
					<simpara>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="images/logs.png" format="PNG" />
							</imageobject>
							<textobject>
								<phrase>View usage logs</phrase>
							</textobject>
						</inlinemediaobject>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						From the Usage Logs page, you can:
					</simpara>
					<itemizedlist>
						<listitem>
							<simpara>
								Set the date range for viewing log entries by adding dates to the From and to boxes. By default, the most recent one week of log entries is displayed.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Type a string into the Filter Logs box to display log entries that container the given string.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								Toggle the arrow to the left of any log entry to see more or less text associated with that log entry.
							</simpara>
						</listitem>
					</itemizedlist>
				</listitem>
			</orderedlist>
		</section>
		<section xml:id="use-quay-export-logs">
			<title>Exporting repository logs</title>
			<simpara>
				To be able to grab a larger number of log files and save them outside of the Red Hat Quay database, you can use the Export Logs feature. Here are a few things you should know about using Export Logs:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						You can choose a range of dates for the logs you want to gather from a repository.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						You can request that the logs be sent to you via an email attachment or directed to a callback URL.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						You need Admin privilege to the repository or namespace to export logs
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						A maximum of 30 days of log data can be exported at a time
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Export Logs only gathers log data that was previously produced. It does not stream logging data.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Your Red Hat Quay instance must be configured for external storage for this feature (local storage will not work).
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Once the logs are gathered and available, you should immediately copy that data if you want to save it. By default, the data expires in an hour.
					</simpara>
				</listitem>
			</itemizedlist>
			<simpara>
				To use the Export Logs feature:
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						Select a repository for which you have Admin privileges.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select the Usage Logs icon from the left column. A Usage Logs screen appears.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Choose the From and to date range of the log entries you want to gather.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select the Export Logs button. An Export Usage Logs pop-up appears, as shown
					</simpara>
					<simpara>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="images/export-usage-logs.png" format="PNG" />
							</imageobject>
							<textobject>
								<phrase>Enter email or callback URL to receive exported logs</phrase>
							</textobject>
						</inlinemediaobject>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Enter the email address or callback URL you want to receive the exported logs. For the callback URL, you could use a URL to a place such as webhook.site.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select Start Logs Export. This causes Red Hat Quay to begin gathering the selected log entries. Depending on the amount of logging data being gathered, this can take anywhere from one minute to an hour to complete.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						When the log export is completed you will either:
					</simpara>
					<itemizedlist>
						<listitem>
							<simpara>
								Receive an email, alerting you to the availability of your requested exported log entries.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								See a successful status of your log export request from the webhook URL. A link to the exported data will be available for you to select to download the logs.
							</simpara>
						</listitem>
					</itemizedlist>
				</listitem>
			</orderedlist>
			<simpara>
				Keep in mind that the URL points to a location in your Red Hat Quay external storage and is set to expire within an hour. So make sure you copy the exported logs before that expiration time if you intend to keep them.
			</simpara>
		</section>
	</chapter>
	<chapter xml:id="build-support">
		<title>Automatically building Dockerfiles with Build workers</title>
		<simpara>
			Red Hat Quay supports building Dockerfiles using a set of worker nodes on OpenShift or Kubernetes. Build triggers, such as GitHub webhooks can be configured to automatically build new versions of your repositories when new code is committed. This document will walk you through enabling builds with your Red Hat Quay installation and setting up one or more OpenShift/K8s clusters to accept builds from Red Hat Quay. With Red Hat Quay 3.4, the underlying Build Manager has been completely re-written as part of Red Hat Quay’s migration from Python 2 to Python 3. As a result, builder nodes are now dynamically created as Kubernetes Jobs versus builder nodes that ran continuously in Red Hat Quay 3.3 and earlier. This greatly simplifies how Red Hat Quay manages builds and provides the same mechanism quay.io utilizes to handle thousands of container image builds daily. Customers who are currently running static (“Enterprise” builders under Red Hat Quay 3.3) will be required to migrate to a Kubernetes-based build mechanism.
		</simpara>
		<section xml:id="architecture-overview">
			<title>Architecture Overview</title>
			<simpara>
				The Red Hat Quay Build system is designed for scalability (since it is used to host all builds at quay.io). The Build Manager component of Red Hat Quay provides an orchestration layer that tracks build requests and ensures that a Build Executor (OpenShift/K8s cluster) will carry out each request. Each build is handled by a Kubernetes Job which launches a small virtual machine to completely isolate and contain the image build process. This ensures that container builds do not affect each other or the underlying build system. Multiple Executors can be configured to ensure that builds are performed even in the event of infrastructure failures. Red Hat Quay will automatically send builds to a different Executor if it detects that one Executor is having difficulties.
			</simpara>
			<note>
				<simpara>
					The upstream version of Red Hat Quay provides instructions on how to configure an AWS/EC2 based Executor. This configuration is not supported for Red Hat Quay customers.
				</simpara>
			</note>
			<section remap="_build_manager" xml:id="build_manager">
				<title>Build manager</title>
				<simpara>
					The build manager is responsible for the lifecycle of scheduled build. Operations requiring updating the build queue, build phase and running jobs’ status is handled by the build manager.
				</simpara>
			</section>
			<section remap="_build_workers_control_plane" xml:id="build_workers_control_plane">
				<title>Build workers’ control plane</title>
				<simpara>
					Build jobs are run on separate worker nodes, and are scheduled on separate control planes (executor). Currently, Red Hat Quay supports running jobs on AWS and Kubernetes. Builds are executed using quay.io/quay/quay-builder. On AWS, builds are scheduled on EC2 instances. On k8s, the builds are scheduled as job resources.
				</simpara>
			</section>
			<section remap="_orchestrator" xml:id="orchestrator">
				<title>Orchestrator</title>
				<simpara>
					The orchestrator is used to store the state of currently running build jobs, and publish events for the build manager to consume. e.g expiry events. Currently, the supported orchestrator backend is Redis.
				</simpara>
			</section>
		</section>
		<section xml:id="openshift-requirements">
			<title>OpenShift Requirements</title>
			<simpara>
				Red Hat Quay builds are supported on Kubernetes and OpenShift 4.5 and higher. A bare metal (non-virtualized) worker node is required since build pods require the ability to run kvm virtualization. Each build is done in an ephemeral virtual machine to ensure complete isolation and security while the build is running. In addition, your OpenShift cluster should permit the ServiceAccount associated with Red Hat Quay builds to run with the necessary SecurityContextConstraint to support privileged containers.
			</simpara>
		</section>
		<section xml:id="orchestrator-requirements">
			<title>Orchestrator Requirements</title>
			<simpara>
				The Red Hat Quay builds need access to a Redis instance to track build status information. It is acceptable to use the same Redis instance already deployed with your Red Hat Quay installation. All build queues are managed in the Red Hat Quay database so there is no need for a highly available Redis instance.
			</simpara>
		</section>
		<section xml:id="setting-up-builders">
			<title>Setting Up Red Hat Quay Builders With OpenShift</title>
			<section remap="_prepare_openshift_for_red_hat_quay_builds" xml:id="prepare_openshift_for_red_hat_quay_builds">
				<title>Prepare OpenShift for Red Hat Quay Builds</title>
				<simpara>
					There are several actions that are needed on an OpenShift cluster before it can accept builds from Red Hat Quay.
				</simpara>
				<orderedlist numeration="arabic">
					<listitem>
						<simpara>
							Create a project where builds will be run (e.g. ‘builder’)
						</simpara>
						
<screen>$ oc new-project builder</screen>
					</listitem>
					<listitem>
						<simpara>
							Create a <literal>ServiceAccount</literal> in this <literal>Project</literal> that will be used to run builds. Ensure that it has sufficient privileges to create <literal>Jobs</literal> and <literal>Pods</literal>. Copy the <literal>ServiceAccount</literal>’s token for use later.
						</simpara>
						
<screen>$ oc create sa -n builder quay-builder
$ oc policy add-role-to-user -n builder edit system:serviceaccount:builder:quay-builder
$ oc sa get-token -n builder quay-builder</screen>
					</listitem>
					<listitem>
						<simpara>
							Identify the URL for the OpenShift cluster’s API server. This can be found from the OpenShift Console.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							Identify a worker node label to be used when scheduling build <literal>Jobs</literal>. Because build pods need to run on bare metal worker nodes, typically these are identified with specific labels. Check with your cluster administrator to determine exactly which node label should be used.
						</simpara>
					</listitem>
					<listitem>
						<simpara>
							If the cluster is using a self-signed certificate, get the kube apiserver’s CA to add to Red Hat Quay’s extra certs.
						</simpara>
						<orderedlist numeration="loweralpha">
							<listitem>
								<simpara>
									Get the name of the secret containing the CA:
								</simpara>
								
<screen>$ oc get sa openshift-apiserver-sa --namespace=openshift-apiserver -o json | jq '.secrets[] | select(.name | contains("openshift-apiserver-sa-token"))'.name</screen>
							</listitem>
							<listitem>
								<simpara>
									Get the <literal>ca.crt</literal> key value from the secret in the Openshift console. The value should begin with “-----BEGIN CERTIFICATE-----”
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									Import the CA in Red Hat Quay using the ConfigTool. Ensure the name of this file matches <literal>K8S_API_TLS_CA</literal>.
								</simpara>
							</listitem>
						</orderedlist>
					</listitem>
					<listitem>
						<simpara>
							Create the necessary security contexts/role bindings for the <literal>ServiceAccount</literal>:
						</simpara>
					</listitem>
				</orderedlist>
				
<screen>apiVersion: security.openshift.io/v1
kind: SecurityContextConstraints
metadata:
  name: quay-builder
priority: null
readOnlyRootFilesystem: false
requiredDropCapabilities: null
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: RunAsAny
seccompProfiles:
- '*'
supplementalGroups:
  type: RunAsAny
volumes:
- '*'
allowHostDirVolumePlugin: true
allowHostIPC: true
allowHostNetwork: true
allowHostPID: true
allowHostPorts: true
allowPrivilegeEscalation: true
allowPrivilegedContainer: true
allowedCapabilities:
- '*'
allowedUnsafeSysctls:
- '*'
defaultAddCapabilities: null
fsGroup:
  type: RunAsAny
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: quay-builder-scc
  namespace: builder
rules:
- apiGroups:
  - security.openshift.io
  resourceNames:
  - quay-builder
  resources:
  - securitycontextconstraints
  verbs:
  - use
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: quay-builder-scc
  namespace: builder
subjects:
- kind: ServiceAccount
  name: quay-builder
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: quay-builder-scc</screen>
			</section>
			<section remap="_enable_builders_and_add_build_configuration_to_red_hat_quay_s_configuration_bundle" xml:id="enable_builders_and_add_build_configuration_to_red_hat_quay_s_configuration_bundle">
				<title>Enable Builders and add Build Configuration to Red Hat Quay’s Configuration Bundle</title>
				<orderedlist numeration="arabic">
					<listitem>
						<simpara>
							Ensure that you’ve got Builds enabled in your Red Hat Quay configuration.
						</simpara>
					</listitem>
				</orderedlist>
				
<screen>FEATURE_BUILD_SUPPORT: True</screen>
				<orderedlist numeration="arabic">
					<listitem>
						<simpara>
							Add the following to your Red Hat Quay configuration bundle, replacing each value with a value specific to your installation.
						</simpara>
					</listitem>
				</orderedlist>
				<note>
					<simpara>
						Currently only the Build feature itself can be enabled via the Red Hat Quay Config Tool. The actual configuration of the Build Manager and Executors must be done manually in the config.yaml file.
					</simpara>
				</note>
				
<programlisting language="yaml" linenumbering="unnumbered">BUILD_MANAGER:
- ephemeral
- ALLOWED_WORKER_COUNT: 1
  ORCHESTRATOR_PREFIX: buildman/production/
  ORCHESTRATOR:
    REDIS_HOST: quay-redis-host
    REDIS_PASSWORD: quay-redis-password
    REDIS_SSL: true
    REDIS_SKIP_KEYSPACE_EVENT_SETUP: false
  EXECUTORS:
  - EXECUTOR: kubernetes
    BUILDER_NAMESPACE: builder
    K8S_API_SERVER: api.openshift.somehost.org:6443
    K8S_API_TLS_CA: /conf/stack/extra_ca_cert_build_cluster.crt
    VOLUME_SIZE: 8G
    KUBERNETES_DISTRIBUTION: openshift
    CONTAINER_MEMORY_LIMITS: 5120Mi
    CONTAINER_CPU_LIMITS: 1000m
    CONTAINER_MEMORY_REQUEST: 3968Mi
    CONTAINER_CPU_REQUEST: 500m
    NODE_SELECTOR_LABEL_KEY: beta.kubernetes.io/instance-type
    NODE_SELECTOR_LABEL_VALUE: n1-standard-4
    CONTAINER_RUNTIME: podman
    SERVICE_ACCOUNT_NAME: *****
    SERVICE_ACCOUNT_TOKEN: *****
    QUAY_USERNAME: quay-username
    QUAY_PASSWORD: quay-password
    WORKER_IMAGE: &lt;registry&gt;/quay-quay-builder
    WORKER_TAG: some_tag
    BUILDER_VM_CONTAINER_IMAGE: &lt;registry&gt;/quay-quay-builder-qemu-rhcos:v3.4.0
    SETUP_TIME: 180
    MINIMUM_RETRY_THRESHOLD: 0
    SSH_AUTHORIZED_KEYS:
    - ssh-rsa 12345 someuser@email.com
    - ssh-rsa 67890 someuser2@email.com</programlisting>
				<simpara>
					Each configuration field is explained below.
				</simpara>
				<variablelist>
					<varlistentry>
						<term>ALLOWED_WORKER_COUNT</term>
						<listitem>
							<simpara>
								Defines how many Build Workers are instantiated per Red Hat Quay Pod. Typically this is ‘1’.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>ORCHESTRATOR_PREFIX</term>
						<listitem>
							<simpara>
								Defines a unique prefix to be added to all Redis keys (useful to isolate Orchestrator values from other Redis keys).
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>REDIS_HOST</term>
						<listitem>
							<simpara>
								Hostname for your Redis service.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>REDIS_PASSWORD</term>
						<listitem>
							<simpara>
								Password to authenticate into your Redis service.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>REDIS_SSL</term>
						<listitem>
							<simpara>
								Defines whether or not your Redis connection uses SSL.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>REDIS_SKIP_KEYSPACE_EVENT_SETUP</term>
						<listitem>
							<simpara>
								By default, Red Hat Quay does not set up the keyspace events required for key events at runtime. To do so, set REDIS_SKIP_KEYSPACE_EVENT_SETUP to <literal>false</literal>.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>EXECUTOR</term>
						<listitem>
							<simpara>
								Starts a definition of an Executor of this type. Valid values are ‘kubernetes’ and ‘ec2’
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>BUILDER_NAMESPACE</term>
						<listitem>
							<simpara>
								Kubernetes namespace where Red Hat Quay builds will take place
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>K8S_API_SERVER</term>
						<listitem>
							<simpara>
								Hostname for API Server of OpenShift cluster where builds will take place
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>K8S_API_TLS_CA</term>
						<listitem>
							<simpara>
								The filepath in the <literal>Quay</literal> container of the build cluster’s CA certificate for the Quay app to trust when making API calls.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>KUBERNETES_DISTRIBUTION</term>
						<listitem>
							<simpara>
								Indicates which type of Kubernetes is being used. Valid values are ‘openshift’ and ‘k8s’.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>CONTAINER_*</term>
						<listitem>
							<simpara>
								Define the resource requests and limits for each build pod.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>NODE_SELECTOR_*</term>
						<listitem>
							<simpara>
								Defines the node selector label name/value pair where build Pods should be scheduled.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>CONTAINER_RUNTIME</term>
						<listitem>
							<simpara>
								Specifies whether the builder should run <literal>docker</literal> or <literal>podman</literal>. Customers using Red Hat’s <literal>quay-builder</literal> image should set this to <literal>podman</literal>.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>SERVICE_ACCOUNT_NAME/SERVICE_ACCOUNT_TOKEN</term>
						<listitem>
							<simpara>
								Defines the Service Account name/token that will be used by build Pods.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>QUAY_USERNAME/QUAY_PASSWORD</term>
						<listitem>
							<simpara>
								Defines the registry credentials needed to pull the Red Hat Quay build worker image that is specified in the WORKER_IMAGE field. Customers should provide a Red Hat Service Account credential as defined in the section "Creating Registry Service Accounts" against registry.redhat.io in the article at <link xlink:href="https://access.redhat.com/RegistryAuthentication">https://access.redhat.com/RegistryAuthentication</link>.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>WORKER_IMAGE</term>
						<listitem>
							<simpara>
								Image reference for the Red Hat Quay builder image. registry.redhat.io/quay/quay-builder
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>WORKER_TAG</term>
						<listitem>
							<simpara>
								Tag for the builder image desired. The latest version is v3.4.0.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>BUILDER_VM_CONTAINER_IMAGE</term>
						<listitem>
							<simpara>
								The full reference to the container image holding the internal VM needed to run each Red Hat Quay build (<literal>registry.redhat.io/quay/quay-builder-qemu-rhcos:v3.4.0</literal>).
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>SETUP_TIME</term>
						<listitem>
							<simpara>
								Specifies the number of seconds at which a build times out if it has not yet registered itself with the Build Manager (default is 500 seconds). Builds that time out are attempted to be restarted three times. If the build does not register itself after three attempts it is considered failed.
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>MINIMUM_RETRY_THRESHOLD</term>
						<listitem>
							<simpara>
								This setting is used with multiple Executors; it indicates how many retries are attempted to start a build before a different Executor is chosen. Setting to 0 means there are no restrictions on how many tries the build job needs to have. This value should be kept intentionally small (three or less) to ensure failovers happen quickly in the event of infrastructure failures. E.g Kubernetes is set as the first executor and EC2 as the second executor. If we want the last attempt to run a job to always be executed on EC2 and not Kubernetes, we would set the Kubernetes executor’s <literal>MINIMUM_RETRY_THRESHOLD</literal> to 1 and EC2’s <literal>MINIMUM_RETRY_THRESHOLD</literal> to 0 (defaults to 0 if not set). In this case, kubernetes’ <literal>MINIMUM_RETRY_THRESHOLD</literal> &gt; retries_remaining(1) would evaluate to False, thus falling back to the second executor configured
							</simpara>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>SSH_AUTHORIZED_KEYS</term>
						<listitem>
							<simpara>
								List of ssh keys to bootstrap in the ignition config. This allows other keys to be used to ssh into the EC2 instance or QEMU VM
							</simpara>
						</listitem>
					</varlistentry>
				</variablelist>
			</section>
		</section>
		<section remap="_openshift_routes_limitation" xml:id="openshift_routes_limitation">
			<title>OpenShift Routes Limitation</title>
			<note>
				<simpara>
					This section only applies if you are using the Quay Operator on OpenShift with managed <literal>route</literal> component.
				</simpara>
			</note>
			<simpara>
				Due to a limitation of OpenShift <literal>Routes</literal> to only be able to serve traffic to a single port, additional steps are required to set up builds. Ensure that your <literal>kubectl</literal> or <literal>oc</literal> CLI tool is configured to work with the cluster where the Quay Operator is installed and that your <literal>QuayRegistry</literal> exists (not necessarily the same as the bare metal cluster where your builders run).
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						Ensure that HTTP/2 ingress is enabled on the OpenShift cluster by following <link xlink:href="https://docs.openshift.com/container-platform/4.5/networking/ingress-operator.html#nw-http2-haproxy_configuring-ingress">these steps</link>.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						The Quay Operator will create a <literal>Route</literal> which directs gRPC traffic to the build manager server running inside the existing Quay pod(s). If you want to use a custom hostname (such as a subdomain like <literal>builder.registry.example.com</literal>), ensure that you create a CNAME record with your DNS provider which points to the <literal>status.ingress[0].host</literal> of the created <literal>Route</literal>:
					</simpara>
					
<screen>$ kubectl get -n &lt;namespace&gt; route &lt;quayregistry-name&gt;-quay-builder -o jsonpath={.status.ingress[0].host}</screen>
				</listitem>
				<listitem>
					<simpara>
						Using the OpenShift UI or CLI, update the <literal>Secret</literal> referenced by <literal>spec.configBundleSecret</literal> of the <literal>QuayRegistry</literal> with the build cluster CA certificate (name the key <literal>extra_ca_cert_build_cluster.cert</literal>), and update the <literal>config.yaml</literal> entry with the correct values referenced in the builder config above (depending on your build executor) along with the <literal>BUILDMAN_HOSTNAME</literal> field:
					</simpara>
					
<programlisting language="yaml" linenumbering="unnumbered">BUILD_MANAGER:
- ephemeral
- ALLOWED_WORKER_COUNT: 1
  ORCHESTRATOR_PREFIX: buildman/production/
  ORCHESTRATOR:
    REDIS_HOST: quay-redis-host
    REDIS_PASSWORD: quay-redis-password
    REDIS_SSL: true
    REDIS_SKIP_KEYSPACE_EVENT_SETUP: false
  EXECUTORS:
  - EXECUTOR: kubernetes
    BUILDER_NAMESPACE: builder
    BUILDMAN_HOSTNAME: &lt;build-manager-hostname&gt;
    ...</programlisting>
				</listitem>
			</itemizedlist>
			<simpara>
				The extra configuration field is explained below:
			</simpara>
			<variablelist>
				<varlistentry>
					<term>BUILDMAN_HOSTNAME</term>
					<listitem>
						<simpara>
							The externally accessible server hostname which the build jobs use to communicate back to the build manager. Default is the same as <literal>SERVER_HOSTNAME</literal>. For OpenShift <literal>Route</literal>, it is either <literal>status.ingress[0].host</literal> or the CNAME entry if using a custom hostname. <literal>BUILDMAN_HOSTNAME</literal> <emphasis role="strong">needs</emphasis> to include the port number, e.g <literal>somehost:443</literal> for Openshift Route, as the gRPC client used to communicate with the build manager does not infer any port if omitted.
						</simpara>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>
		<section remap="_troubleshooting_builds" xml:id="troubleshooting_builds">
			<title>Troubleshooting Builds</title>
			<simpara>
				The builder instances started by the build manager are ephemeral. This means that they will either get shut down by Red Hat Quay} on timeouts/failure or garbage collected by the control plane (EC2/K8s). This means that in order to get the builder logs, one needs to do so <emphasis role="strong">while</emphasis> the builds are running.
			</simpara>
			<section remap="_debug_config_flag" xml:id="debug_config_flag">
				<title>DEBUG config flag</title>
				<simpara>
					A DEBUG flag can be set in order to prevent the builder instances from getting cleaned up after completion/failure. To do so, in the desired executor configuration, set DEBUG to true. For example:
				</simpara>
				
<programlisting language="yaml" linenumbering="unnumbered">  EXECUTORS:
    - EXECUTOR: ec2
      DEBUG: true
      ...
    - EXECUTOR: kubernetes
      DEBUG: true
      ...</programlisting>
				<simpara>
					When set to true, DEBUG will prevent the build nodes from shutting down after the quay-builder service is done or fails, and will prevent the build manager from cleaning up the instances (terminating EC2 instances or deleting k8s jobs). This will allow debugging builder node issues, and <emphasis role="strong">should not</emphasis> be set in a production environment. The lifetime service will still exist. i.e The instance will still shutdown after approximately 2 hours (EC2 instances will terminate, k8s jobs will complete) Setting DEBUG will also affect ALLOWED_WORKER_COUNT, as the unterminated instances/jobs will still count towards the total number of running workers. This means the existing builder workers will need to manually be deleted if ALLOWED_WORKER_COUNT is reached to be able to schedule new builds.
				</simpara>
				<simpara>
					Use the followings steps:
				</simpara>
				<orderedlist numeration="arabic">
					<listitem>
						<simpara>
							The guest VM forwards its SSH port (22) to its host’s (the pod) port 2222. Port forward the builder pod’s port 2222 to a port on localhost. e.g
						</simpara>
						
<screen>$ kubectl port-forward &lt;builder pod&gt; 9999:2222</screen>
					</listitem>
					<listitem>
						<simpara>
							SSH into the VM running inside the container using a key set from SSH_AUTHORIZED_KEYS:
						</simpara>
						
<screen>$ ssh -i /path/to/ssh/key/set/in/ssh_authorized_keys -p 9999 core@localhost</screen>
					</listitem>
					<listitem>
						<simpara>
							Get the quay-builder service logs:
						</simpara>
						
<screen>$ systemctl status quay-builder
$ journalctl -f -u quay-builder</screen>
						<itemizedlist>
							<listitem>
								<simpara>
									Step 2-3 can also be done in a single SSH command:
								</simpara>
								
<screen>$ ssh -i /path/to/ssh/key/set/in/ssh_authorized_keys -p 9999 core@localhost ‘systemctl status quay-builder’
$ ssh -i /path/to/ssh/key/set/in/ssh_authorized_keys -p 9999 core@localhost ‘journalctl -f -u quay-builder’</screen>
							</listitem>
						</itemizedlist>
					</listitem>
				</orderedlist>
			</section>
		</section>
		<section xml:id="set-up-github-build">
			<title>Setting up GitHub builds (optional)</title>
			<simpara>
				If your organization plans to have builds be conducted via pushes to GitHub (or GitHub Enterprise), continue with <emphasis>Creating an OAuth application in GitHub</emphasis>.
			</simpara>
		</section>
	</chapter>
	<chapter remap="_building_dockerfiles" xml:id="building_dockerfiles">
		<title>Building Dockerfiles</title>
		<simpara>
			Red Hat Quay supports the ability to build <link xlink:href="http://docs.docker.com/reference/builder/">Dockerfiles</link> on our build fleet and push the resulting image to the repository.
		</simpara>
		<section xml:id="viewing-and-managing-builds">
			<title>Viewing and managing builds</title>
			<simpara>
				Repository Builds can be viewed and managed by clicking the Builds tab in the <literal>Repository View</literal>.
			</simpara>
		</section>
		<section xml:id="manually-starting-a-build">
			<title>Manually starting a build</title>
			<simpara>
				To manually start a repository build, click the <literal>+</literal> icon in the top right of the header on any repository page and choose <literal>New Dockerfile Build</literal>. An uploaded <literal>Dockerfile</literal>, <literal>.tar.gz</literal>, or an HTTP URL to either can be used for the build.
			</simpara>
			<note>
				<simpara>
					You will not be able to specify the Docker build context when manually starting a build.
				</simpara>
			</note>
		</section>
		<section xml:id="build-triggers">
			<title>Build Triggers</title>
			<simpara>
				Repository builds can also be automatically triggered by events such as a push to an SCM (GitHub, BitBucket or GitLab) or via <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3.6/html-single/use_red_hat_quay/#webhook">a call to a webhook</link>.
			</simpara>
			<section xml:id="creating-a-new-build-trigger">
				<title>Creating a new build trigger</title>
				<simpara>
					To setup a build trigger, click the <literal>Create Build Trigger</literal> button on the Builds view page and follow the instructions of the dialog. You will need to grant Red Hat Quay access to your repositories in order to setup the trigger and your account <emphasis>requires admin access on the SCM repository</emphasis>.
				</simpara>
			</section>
			<section xml:id="manually-triggering-a-build-trigger">
				<title>Manually triggering a build trigger</title>
				<simpara>
					To trigger a build trigger manually, click the icon next to the build trigger and choose <literal>Run Now</literal>.
				</simpara>
			</section>
			<section xml:id="build-contexts">
				<title>Build Contexts</title>
				<simpara>
					When building an image with Docker, a directory is specified to become the build context. This holds true for both manual builds and build triggers because the builds conducted by Red Hat Quay are no different from running <literal>docker build</literal> on your own machine.
				</simpara>
				<simpara>
					Red Hat Quay build contexts are always the specified <emphasis>subdirectory</emphasis> from the build setup and fallback to the root of the build source if none is specified. When a build is triggered, Red Hat Quay build workers clone the git repository to the worker machine and enter the build context before conducting a build.
				</simpara>
				<simpara>
					For builds based on tar archives, build workers extract the archive and enter the build context. For example:
				</simpara>
				
<screen>example
├── .git
├── Dockerfile
├── file
└── subdir
    └── Dockerfile</screen>
				<simpara>
					Imagine the example above is the directory structure for a GitHub repository called "example". If no subdirectory is specified in the build trigger setup or while manually starting a build, the build will operate in the example directory.
				</simpara>
				<simpara>
					If <literal>subdir</literal> is specified to be the subdirectory in the build trigger setup, only the Dockerfile within it is visible to the build. This means that you cannot use the <literal>ADD</literal> command in the Dockerfile to add <literal>file</literal>, because it is outside of the build context.
				</simpara>
				<simpara>
					Unlike the Docker Hub, the Dockerfile is part of the build context on Red Hat Quay. Thus, it must not appear in the <literal>.dockerignore</literal> file.
				</simpara>
			</section>
		</section>
	</chapter>
	<chapter remap="_setting_up_a_custom_git_trigger" xml:id="setting_up_a_custom_git_trigger">
		<title>Setting up a Custom Git Trigger</title>
		<simpara>
			A Custom Git Trigger is a generic way for any git server to act as a build trigger. It relies solely on SSH keys and webhook endpoints; everything else is left to the user to implement.
		</simpara>
		<section xml:id="creating-a-custom-git-trigger">
			<title>Creating a Trigger</title>
			<simpara>
				Creating a Custom Git Trigger is similar to the creation of any other trigger with a few subtle differences:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						It is not possible for Red Hat Quay to automatically detect the proper robot account to use with the trigger. This must be done manually in the creation process.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						There are extra steps after the creation of the trigger that must be done in order to use the trigger. These steps are detailed below.
					</simpara>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="post-git-trigger-creation-setup">
			<title>Post trigger-creation setup</title>
			<simpara>
				Once a trigger has been created, <emphasis role="strong">there are 2 additional steps required</emphasis> before the trigger can be used:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						Provide read access to the <emphasis>SSH public key</emphasis> generated when creating the trigger.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Setup a <emphasis>webhook</emphasis> that POSTs to the Red Hat Quay endpoint to trigger a build.
					</simpara>
				</listitem>
			</itemizedlist>
			<simpara>
				The key and the URL are both available at all times by selecting <literal>View Credentials</literal> from the gear located in the trigger listing. 
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="images/view-credentials.png" format="PNG" />
					</imageobject>
					<textobject>
						<phrase>View and modify tags from your repository</phrase>
					</textobject>
				</inlinemediaobject>
			</simpara>
			<section xml:id="ssh-public-key-access">
				<title>SSH public key access</title>
				<simpara>
					Depending on the Git server setup, there are various ways to install the SSH public key that Red Hat Quay generates for a custom git trigger. For example, <link xlink:href="https://git-scm.herokuapp.com/book/en/v2/Git-on-the-Server-Getting-Git-on-a-Server">Git documentation</link> describes a small server setup in which simply adding the key to <literal>$HOME/.ssh/authorize_keys</literal> would provide access for builders to clone the repository. For any git repository management software that isn’t officially supported, there is usually a location to input the key often labeled as <literal>Deploy Keys</literal>.
				</simpara>
			</section>
			<section xml:id="webhook">
				<title>Webhook</title>
				<simpara>
					In order to automatically trigger a build, one must POST a JSON payload to the webhook URL with the following format:
				</simpara>
				
<screen>{
  "commit": "1c002dd",                                   // required
  "ref": "refs/heads/master",                            // required
  "default_branch": "master",                            // required
  "commit_info": {                                       // optional
    "url": "gitsoftware.com/repository/commits/1234567", // required
    "message": "initial commit",                         // required
    "date": "timestamp",                                 // required
    "author": {                                          // optional
      "username": "user",                                // required
      "avatar_url": "gravatar.com/user.png",             // required
      "url": "gitsoftware.com/users/user"                // required
    },
    "committer": {                                       // optional
      "username": "user",                                // required
      "avatar_url": "gravatar.com/user.png",             // required
      "url": "gitsoftware.com/users/user"                // required
    }
  }
}</screen>
				<note>
					<simpara>
						This request requires a <literal>Content-Type</literal> header containing <literal>application/json</literal> in order to be valid.
					</simpara>
				</note>
				<simpara>
					Once again, this can be accomplished in various ways depending on the server setup, but for most cases can be done via a <link xlink:href="https://git-scm.herokuapp.com/book/en/v2/Customizing-Git-Git-Hooks#idp26374144">post-receive git hook</link>.
				</simpara>
			</section>
		</section>
	</chapter>
	<chapter remap="_skipping_a_source_control_triggered_build" xml:id="skipping_a_source_control_triggered_build">
		<title>Skipping a source control-triggered build</title>
		<simpara xml:id="skipping-source-control-trigger-build">
			To specify that a commit should be ignored by the Red Hat Quay build system, add the text <literal>[skip build]</literal> or <literal>[build skip]</literal> anywhere in the commit message.
		</simpara>
	</chapter>
	<chapter xml:id="github-build-triggers">
		<title>Set up GitHub build trigger tags</title>
		<simpara>
			Red Hat Quay supports using GitHub or GitHub Enterprise as a trigger to building images. If you have not yet done so, go ahead and <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3.6/html-single/use_red_hat_quay/index#build-support">enable build support in Red Hat Quay</link>.
		</simpara>
		<section remap="_understanding_tag_naming_for_build_triggers" xml:id="understanding_tag_naming_for_build_triggers">
			<title>Understanding tag naming for build triggers</title>
			<simpara>
				Prior to Red Hat Quay 3.3, how images created from build triggers were named was limited. Images built by build triggers were named:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						With the branch or tag whose change invoked the trigger
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						With a <literal>latest</literal> tag for images that used the default branch
					</simpara>
				</listitem>
			</itemizedlist>
			<simpara>
				As of Red Hat Quay 3.3 and later, you have more flexibility in how you set image tags. The first thing you can do is enter custom tags, to have any string of characters assigned as a tag for each built image. However, as an alternative, you could use the following tag templates to to tag images with information from each commit:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						<emphasis role="strong">${commit_info.short_sha}</emphasis>: The commit’s short SHA
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">${commit_info.date}</emphasis>: The timestamp for the commit
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">${commit_info.author}</emphasis>: The author from the commit
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">${commit_info.committer}</emphasis>: The committer of the commit
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">${parsed_ref.branch}</emphasis>: The branch name
					</simpara>
				</listitem>
			</itemizedlist>
			<simpara>
				The following procedure describes how you set up tagging for build triggers.
			</simpara>
		</section>
		<section remap="_setting_tag_names_for_build_triggers" xml:id="setting_tag_names_for_build_triggers">
			<title>Setting tag names for build triggers</title>
			<simpara>
				Follow these steps to configure custom tags for build triggers:
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						From the repository view, select the Builds icon from the left navigation.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select the Create Build Trigger menu, and select the type of repository push you want (GitHub, Bitbucket, GitLab, or Custom Git repository push). For this example, <emphasis>GitHub Repository Push</emphasis> is chosen, as illustrated in the following figure.
					</simpara>
					<simpara>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="images/create-build-trigger.png" format="PNG" />
							</imageobject>
							<textobject>
								<phrase>Choose the type of build trigger to use</phrase>
							</textobject>
						</inlinemediaobject>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						When the <emphasis>Setup Build Trigger</emphasis> page appears, select the repository and namespace in which you want the trigger set up.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Under Configure Trigger, select either <emphasis>Trigger for all branches and tags</emphasis> or <emphasis>Trigger only on branches and tags matching a regular expression</emphasis>. Then select Continue. The Configure Tagging section appears, as shown in the following figure:
					</simpara>
					<simpara>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="images/configure-tagging.png" format="PNG" />
							</imageobject>
							<textobject>
								<phrase>Set tagging with your own tags or using tag templates</phrase>
							</textobject>
						</inlinemediaobject>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Scroll down to <emphasis>Configure Tagging</emphasis> and select from the following options:
					</simpara>
					<itemizedlist>
						<listitem>
							<simpara>
								<emphasis role="strong">Tag manifest with the branch or tag name</emphasis>: Check this box to use the name of the branch or tag in which the commit occurred as the tag used on the image. This is enabled by default.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								<emphasis role="strong">Add latest tag if on default branch</emphasis>: Check this box to use the <literal>latest</literal> tag for the image if it is on the default branch for the repository. This is enabled by default.
							</simpara>
						</listitem>
						<listitem>
							<simpara>
								<emphasis role="strong">Add custom tagging templates</emphasis>: Enter a custom tag or a template into the <emphasis>Enter a tag template</emphasis> box. There are multiple tag templates you can enter here, as described earlier in this section. They include ways of using short SHA, timestamps, author name, committer, and branch name from the commit as tags.
							</simpara>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<simpara>
						Select Continue. You are prompted to select the directory build context for the Docker build. The build context directory identifies the location of the directory containing the Dockerfile, along with other files needed when the build is triggered. Enter "/" if the Dockerfile is in the root of the git repository.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select Continue. You are prompted to add an optional Robot Account. Do this if you want to pull a private base image during the build process. The robot account would need access to the build.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select Continue to complete the setup of the build trigger.
					</simpara>
				</listitem>
			</orderedlist>
			<simpara>
				If you were to return to the Repository Builds page for the repository, the build triggers you set up will be listed under the Build Triggers heading.
			</simpara>
			<simpara>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="images/view-tags-set.png" format="PNG" />
					</imageobject>
					<textobject>
						<phrase>See the tagging options you set from the repository view</phrase>
					</textobject>
				</inlinemediaobject>
			</simpara>
		</section>
	</chapter>
	<chapter xml:id="github-app">
		<title>Creating an OAuth application in GitHub</title>
		<simpara>
			You can authorize your registry to access a GitHub account and its repositories by registering it as a GitHub OAuth application.
		</simpara>
		<section xml:id="github-app-create">
			<title>Create new GitHub application</title>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						Log into GitHub (Enterprise)
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Visit the Applications page under your organization’s settings.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Click <link xlink:href="https://github.com/settings/applications/new">Register New Application</link>. The <literal>Register a new OAuth application</literal> configuration screen is displayed: 
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="images/register-app.png" format="PNG" />
							</imageobject>
							<textobject>
								<phrase>Register a new OAuth application</phrase>
							</textobject>
						</inlinemediaobject>
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Set Homepage URL: Enter the Quay Enterprise URL as the <literal>Homepage URL</literal>
					</simpara>
					<note>
						<simpara>
							If using public GitHub, the Homepage URL entered must be accessible by your users. It can still be an internal URL.
						</simpara>
					</note>
				</listitem>
				<listitem>
					<simpara>
						Set Authorization callback URL: Enter <link xlink:href="https://{$RED_HAT_QUAY_URL}/oauth2/github/callback">https://{$RED_HAT_QUAY_URL}/oauth2/github/callback</link> as the Authorization callback URL.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Save your settings by clicking the Register application button. The new new application’s summary is shown:
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Record the Client ID and Client Secret shown for the new application.
					</simpara>
				</listitem>
			</orderedlist>
		</section>
	</chapter>
	<chapter remap="_repository_notifications" xml:id="repository_notifications">
		<title>Repository Notifications</title>
		<simpara>
			Quay supports adding <emphasis>notifications</emphasis> to a repository for various events that occur in the repository’s lifecycle. To add notifications, click the <emphasis role="strong">Settings</emphasis> tab while viewing a repository and select <literal>Create Notification</literal>. From the <literal>When this event occurs</literal> field, select the items for which you want to receive notifications:
		</simpara>
		<simpara>
			<inlinemediaobject>
				<imageobject>
					<imagedata fileref="images/event-select.png" format="PNG" />
				</imageobject>
				<textobject>
					<phrase>Create repository notifications</phrase>
				</textobject>
			</inlinemediaobject>
		</simpara>
		<simpara>
			After selecting an event, further configure it by adding how you will be notified of that event.
		</simpara>
		<note>
			<simpara>
				Adding notifications requires <emphasis>repository admin permission</emphasis>.
			</simpara>
		</note>
		<simpara>
			The following are examples of repository events.
		</simpara>
		<section xml:id="repository-events">
			<title>Repository Events</title>
			<section xml:id="repository-push">
				<title>Repository Push</title>
				<simpara>
					A successful push of one or more images was made to the repository:
				</simpara>
				
<screen>{
  "name": "repository",
  "repository": "dgangaia/test",
  "namespace": "dgangaia",
  "docker_url": "quay.io/dgangaia/test",
  "homepage": "https://quay.io/repository/dgangaia/repository",
  "updated_tags": [
    "latest"
  ]
}</screen>
			</section>
			<section xml:id="dockerfile-build-queued">
				<title>Dockerfile Build Queued</title>
				<simpara>
					Here is a sample response for a Dockerfile build has been queued into the build system. The response can differ based on the use of optional attributes.
				</simpara>
				
<screen>{
  "build_id": "296ec063-5f86-4706-a469-f0a400bf9df2",
  "trigger_kind": "github",                                                       //Optional
  "name": "test",
  "repository": "dgangaia/test",
  "namespace": "dgangaia",
  "docker_url": "quay.io/dgangaia/test",
  "trigger_id": "38b6e180-9521-4ff7-9844-acf371340b9e",                           //Optional
  "docker_tags": [
    "master",
    "latest"
  ],
  "repo": "test",
  "trigger_metadata": {
    "default_branch": "master",
    "commit": "b7f7d2b948aacbe844ee465122a85a9368b2b735",
    "ref": "refs/heads/master",
    "git_url": "git@github.com:dgangaia/test.git",
    "commit_info": {                                                             //Optional
      "url": "https://github.com/dgangaia/test/commit/b7f7d2b948aacbe844ee465122a85a9368b2b735",
      "date": "2019-03-06T12:48:24+11:00",
      "message": "adding 5",
      "author": {                                                                //Optional
        "username": "dgangaia",
        "url": "https://github.com/dgangaia",                                    //Optional
        "avatar_url": "https://avatars1.githubusercontent.com/u/43594254?v=4"    //Optional
      },
      "committer": {
        "username": "web-flow",
        "url": "https://github.com/web-flow",
        "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4"
      }
    }
  },
  "is_manual": false,
  "manual_user": null,
  "homepage": "https://quay.io/repository/dgangaia/test/build/296ec063-5f86-4706-a469-f0a400bf9df2"
}</screen>
			</section>
			<section xml:id="dockerfile-build-started">
				<title>Dockerfile Build Started</title>
				<simpara>
					Here is an example of a Dockerfile build being started by the build system. The response can differ based on some attributes being optional.
				</simpara>
				
<screen>{
  "build_id": "a8cc247a-a662-4fee-8dcb-7d7e822b71ba",
  "trigger_kind": "github",                                                     //Optional
  "name": "test",
  "repository": "dgangaia/test",
  "namespace": "dgangaia",
  "docker_url": "quay.io/dgangaia/test",
  "trigger_id": "38b6e180-9521-4ff7-9844-acf371340b9e",                         //Optional
  "docker_tags": [
    "master",
    "latest"
  ],
  "build_name": "50bc599",
  "trigger_metadata": {                                                         //Optional
    "commit": "50bc5996d4587fd4b2d8edc4af652d4cec293c42",
    "ref": "refs/heads/master",
    "default_branch": "master",
    "git_url": "git@github.com:dgangaia/test.git",
    "commit_info": {                                                            //Optional
      "url": "https://github.com/dgangaia/test/commit/50bc5996d4587fd4b2d8edc4af652d4cec293c42",
      "date": "2019-03-06T14:10:14+11:00",
      "message": "test build",
      "committer": {                                                            //Optional
        "username": "web-flow",
        "url": "https://github.com/web-flow",                                   //Optional
        "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4"   //Optional
      },
      "author": {                                                               //Optional
        "username": "dgangaia",
        "url": "https://github.com/dgangaia",                                   //Optional
        "avatar_url": "https://avatars1.githubusercontent.com/u/43594254?v=4"   //Optional
      }
    }
  },
  "homepage": "https://quay.io/repository/dgangaia/test/build/a8cc247a-a662-4fee-8dcb-7d7e822b71ba"
}</screen>
			</section>
			<section xml:id="dockerfile-build-successfully-completed">
				<title>Dockerfile Build Successfully Completed</title>
				<simpara>
					Here is a sample response of a Dockerfile build that has been successfully completed by the build system.
				</simpara>
				<note>
					<simpara>
						This event will occur <emphasis role="strong">simultaneously</emphasis> with a <emphasis>Repository Push</emphasis> event for the built image(s)
					</simpara>
				</note>
				
<screen>{
  "build_id": "296ec063-5f86-4706-a469-f0a400bf9df2",
  "trigger_kind": "github",                                                       //Optional
  "name": "test",
  "repository": "dgangaia/test",
  "namespace": "dgangaia",
  "docker_url": "quay.io/dgangaia/test",
  "trigger_id": "38b6e180-9521-4ff7-9844-acf371340b9e",                           //Optional
  "docker_tags": [
    "master",
    "latest"
  ],
  "build_name": "b7f7d2b",
  "image_id": "sha256:0339f178f26ae24930e9ad32751d6839015109eabdf1c25b3b0f2abf8934f6cb",
  "trigger_metadata": {
    "commit": "b7f7d2b948aacbe844ee465122a85a9368b2b735",
    "ref": "refs/heads/master",
    "default_branch": "master",
    "git_url": "git@github.com:dgangaia/test.git",
    "commit_info": {                                                              //Optional
      "url": "https://github.com/dgangaia/test/commit/b7f7d2b948aacbe844ee465122a85a9368b2b735",
      "date": "2019-03-06T12:48:24+11:00",
      "message": "adding 5",
      "committer": {                                                              //Optional
        "username": "web-flow",
        "url": "https://github.com/web-flow",                                     //Optional
        "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4"                                                        //Optional
      },
      "author": {                                                                 //Optional
        "username": "dgangaia",
        "url": "https://github.com/dgangaia",                                     //Optional
        "avatar_url": "https://avatars1.githubusercontent.com/u/43594254?v=4"     //Optional
      }
    }
  },
  "homepage": "https://quay.io/repository/dgangaia/test/build/296ec063-5f86-4706-a469-f0a400bf9df2",
  "manifest_digests": [
    "quay.io/dgangaia/test@sha256:2a7af5265344cc3704d5d47c4604b1efcbd227a7a6a6ff73d6e4e08a27fd7d99",
    "quay.io/dgangaia/test@sha256:569e7db1a867069835e8e97d50c96eccafde65f08ea3e0d5debaf16e2545d9d1"
  ]
}</screen>
			</section>
			<section xml:id="dockerfile-build-failed">
				<title>Dockerfile Build Failed</title>
				<simpara>
					A Dockerfile build has failed
				</simpara>
				
<screen>{
  "build_id": "5346a21d-3434-4764-85be-5be1296f293c",
  "trigger_kind": "github",                                                       //Optional
  "name": "test",
  "repository": "dgangaia/test",
  "docker_url": "quay.io/dgangaia/test",
  "error_message": "Could not find or parse Dockerfile: unknown instruction: GIT",
  "namespace": "dgangaia",
  "trigger_id": "38b6e180-9521-4ff7-9844-acf371340b9e",                           //Optional
  "docker_tags": [
    "master",
    "latest"
  ],
  "build_name": "6ae9a86",
  "trigger_metadata": {                                                           //Optional
    "commit": "6ae9a86930fc73dd07b02e4c5bf63ee60be180ad",
    "ref": "refs/heads/master",
    "default_branch": "master",
    "git_url": "git@github.com:dgangaia/test.git",
    "commit_info": {                                                              //Optional
      "url": "https://github.com/dgangaia/test/commit/6ae9a86930fc73dd07b02e4c5bf63ee60be180ad",
      "date": "2019-03-06T14:18:16+11:00",
      "message": "failed build test",
      "committer": {                                                              //Optional
        "username": "web-flow",
        "url": "https://github.com/web-flow",                                     //Optional
        "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4"     //Optional
      },
      "author": {                                                                 //Optional
        "username": "dgangaia",
        "url": "https://github.com/dgangaia",                                     //Optional
        "avatar_url": "https://avatars1.githubusercontent.com/u/43594254?v=4"     //Optional
      }
    }
  },
  "homepage": "https://quay.io/repository/dgangaia/test/build/5346a21d-3434-4764-85be-5be1296f293c"
}</screen>
			</section>
			<section xml:id="dockerfile-build-cancelled">
				<title>Dockerfile Build Cancelled</title>
				<simpara>
					A Dockerfile build was cancelled
				</simpara>
				
<screen>{
  "build_id": "cbd534c5-f1c0-4816-b4e3-55446b851e70",
  "trigger_kind": "github",
  "name": "test",
  "repository": "dgangaia/test",
  "namespace": "dgangaia",
  "docker_url": "quay.io/dgangaia/test",
  "trigger_id": "38b6e180-9521-4ff7-9844-acf371340b9e",
  "docker_tags": [
    "master",
    "latest"
  ],
  "build_name": "cbce83c",
  "trigger_metadata": {
    "commit": "cbce83c04bfb59734fc42a83aab738704ba7ec41",
    "ref": "refs/heads/master",
    "default_branch": "master",
    "git_url": "git@github.com:dgangaia/test.git",
    "commit_info": {
      "url": "https://github.com/dgangaia/test/commit/cbce83c04bfb59734fc42a83aab738704ba7ec41",
      "date": "2019-03-06T14:27:53+11:00",
      "message": "testing cancel build",
      "committer": {
        "username": "web-flow",
        "url": "https://github.com/web-flow",
        "avatar_url": "https://avatars3.githubusercontent.com/u/19864447?v=4"
      },
      "author": {
        "username": "dgangaia",
        "url": "https://github.com/dgangaia",
        "avatar_url": "https://avatars1.githubusercontent.com/u/43594254?v=4"
      }
    }
  },
  "homepage": "https://quay.io/repository/dgangaia/test/build/cbd534c5-f1c0-4816-b4e3-55446b851e70"
}</screen>
			</section>
			<section xml:id="vulnerability-detected">
				<title>Vulnerability Detected</title>
				<simpara>
					A vulnerability was detected in the repository
				</simpara>
				
<screen>{
  "repository": "dgangaia/repository",
  "namespace": "dgangaia",
  "name": "repository",
  "docker_url": "quay.io/dgangaia/repository",
  "homepage": "https://quay.io/repository/dgangaia/repository",

  "tags": ["latest", "othertag"],

  "vulnerability": {
    "id": "CVE-1234-5678",
    "description": "This is a bad vulnerability",
    "link": "http://url/to/vuln/info",
    "priority": "Critical",
    "has_fix": true
  }
}</screen>
			</section>
		</section>
		<section xml:id="notification-actions">
			<title>Notification Actions</title>
			<section xml:id="quay-notification">
				<title>Quay Notification</title>
				<simpara>
					A notification will be added to the Quay.io notification area. The notification area can be found by clicking on the bell icon in the top right of any Quay.io page.
				</simpara>
				<simpara>
					Quay.io notifications can be setup to be sent to a <emphasis>User</emphasis>, <emphasis>Team</emphasis>, or the <emphasis>organization</emphasis> as a whole.
				</simpara>
			</section>
			<section xml:id="e-mail">
				<title>E-mail</title>
				<simpara>
					An e-mail will be sent to the specified address describing the event that occurred.
				</simpara>
				<note>
					<simpara>
						All e-mail addresses will have to be verified on a <emphasis>per-repository</emphasis> basis
					</simpara>
				</note>
			</section>
			<section xml:id="webhook-post">
				<title>Webhook POST</title>
				<simpara>
					An HTTP POST call will be made to the specified URL with the event’s data (see above for each event’s data format).
				</simpara>
				<simpara>
					When the URL is HTTPS, the call will have an SSL client certificate set from Quay.io. Verification of this certificate will prove the call originated from Quay.io. Responses with status codes in the 2xx range are considered successful. Responses with any other status codes will be considered failures and result in a retry of the webhook notification.
				</simpara>
			</section>
			<section xml:id="flowdock-notification">
				<title>Flowdock Notification</title>
				<simpara>
					Posts a message to Flowdock.
				</simpara>
			</section>
			<section xml:id="hipchat-notification">
				<title>Hipchat Notification</title>
				<simpara>
					Posts a message to HipChat.
				</simpara>
			</section>
			<section xml:id="slack-notification">
				<title>Slack Notification</title>
				<simpara>
					Posts a message to Slack.
				</simpara>
			</section>
		</section>
	</chapter>
	<chapter xml:id="oci-intro">
		<title>OCI Support and Red Hat Quay</title>
		<simpara>
			Container registries such as Red Hat Quay were originally designed to support container images in the Docker image format. To promote the use of additional runtimes apart from Docker, the Open Container Initiative (OCI) was created to provide a standardization surrounding container runtimes and image formats. Most container registries support the OCI standardization as it is based on the <link xlink:href="https://docs.docker.com/registry/spec/manifest-v2-2/">Docker image manifest V2, Schema 2</link> format.
		</simpara>
		<simpara>
			In addition to container images, a variety of artifacts have emerged that support not just individual applications, but the Kubernetes platform as a whole. These range from Open Policy Agent (OPA) policies for security and governance to Helm charts and Operators to aid in application deployment.
		</simpara>
		<simpara>
			Red Hat Quay is a private container registry that not only stores container images, but supports an entire ecosystem of tooling to aid in the management of containers. With the release of Red Hat Quay 3.6, support for the use of OCI based artifacts, include Helm charts, cosign, and ztsd compression schemes, has graduated from Technical Preview (TP) and now has General Availability (GA) status.
		</simpara>
		<simpara>
			When Red Hat Quay 3.6 is deployed using the OpenShift Operator, support for Helm and OCI artifacts is now enabled by default. If you need to explicitly enable the feature, for example, if it has previously been disabled or if you have upgraded from a version where it is not enabled by default, see the section <link linkend="config-fields-helm-oci">Explicitly enabling OCI and Helm support</link>.
		</simpara>
		<section xml:id="helm-oci-prereqs">
			<title>Helm and OCI prerequisites</title>
			<itemizedlist>
				<listitem>
					<simpara>
						<emphasis role="strong">Trusted certificates:</emphasis> Communication between the Helm client and Quay is facilitated over HTTPS and as of Helm 3.5, support is only available for registries communicating over HTTPS with trusted certificates. In addition, the operating system must trust the certificates exposed by the registry. Support in future Helm releases will allow for communicating with remote registries insecurely. With that in mind, ensure that your operating system has been configured to trust the certificates used by Quay, for example:
					</simpara>
					
<screen>$ sudo cp rootCA.pem   /etc/pki/ca-trust/source/anchors/
$ sudo update-ca-trust extract</screen>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">Experimental feature:</emphasis> Many of the commands for interacting with Helm and OCI registries make use of the <literal>helm chart</literal> subcommand. At the time of writing, OCI support in Helm is still marked as an “experimental” feature and must be enabled explicitly. This is accomplished by setting the environment variable <literal>HELM_EXPERIMENTAL_OCI=1</literal>.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">Install Helm client:</emphasis> Download your desired version from <link xlink:href="https://github.com/helm/helm/releases">https://github.com/helm/helm/releases</link>, for example, <link xlink:href="https://get.helm.sh/helm-v3.5.3-linux-amd64.tar.gz">https://get.helm.sh/helm-v3.5.3-linux-amd64.tar.gz</link>. Unpack it and move the helm binary to its desired destination:
					</simpara>
					
<screen>$ tar -zxvf helm-v3.5.3-linux-amd64.tar.gz
$ mv linux-amd64/helm /usr/local/bin/helm</screen>
				</listitem>
				<listitem>
					<simpara>
						<emphasis role="strong">Create organization in Quay:</emphasis> Create a new organization for storing the Helm charts, using the Quay registry UI. For example, create an organization named <literal>helm</literal>.
					</simpara>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="helm-oci-quay">
			<title>Using Helm charts with Quay</title>
			<simpara>
				Helm, as a graduated project of the Cloud Native Computing Foundation (CNCF), has become the de facto package manager for Kubernetes as it simplifies how applications are packaged and deployed. Helm uses a packaging format called Charts which contain the Kubernetes resources representing an application. Charts can be made available for general distribution and consumption in repositories. A Helm repository is an HTTP server that serves an index.yaml metadata file and optionally a set of packaged charts. Beginning with Helm version 3, support was made available for distributing charts in OCI registries as an alternative to a traditional repository. To demonstrate how Quay can be used as a registry for Helm charts, an existing chart from a Helm repository will be used to showcase the interaction with OCI registries for chart developers and users.
			</simpara>
			<simpara>
				In the following example, a sample etherpad chart is downloaded from from the Red Hat Community of Practice (CoP) repository and pushed to a local Red Hat Quay repository using the following steps:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						Add the appropriate repository
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Update the repository with the latest metadata
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Download and untar the chart to create a local directory called <literal>etherpad</literal>
					</simpara>
				</listitem>
			</itemizedlist>
			<simpara>
				For example:
			</simpara>
			
<screen>$ helm repo add redhat-cop https://redhat-cop.github.io/helm-charts
$ helm repo update
$ helm pull redhat-cop/etherpad --version=0.0.4 --untar</screen>
			<simpara>
				Tagging the chart requires use of the <literal>helm chart save</literal> command - this corresponds to using <literal>podman tag</literal> for tagging images.
			</simpara>
			
<screen>$ helm chart save ./etherpad example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4

ref:     example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4
digest:  6850d9b21dd4b87cf20ad49f2e2c7def9655c52ea573e1ddb9d1464eeb6a46a6
size:    3.5 KiB
name:    etherpad
version: 0.0.4
0.0.4: saved</screen>
			<simpara>
				Use the <literal>helm chart list</literal> command to see the local instance of the chart:
			</simpara>
			
<screen>helm chart list

REF                                                                               NAME     VERSION DIGEST SIZE   CREATED
example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4 etherpad 0.0.4   ce0233f 3.5 KiB 23 seconds</screen>
			<simpara>
				Before pushing the chart, log in to the repository using the <literal>helm registry login</literal> command:
			</simpara>
			
<screen>$ helm registry login example-registry-quay-quay-enterprise.apps.user1.example.com
Username: quayadmin
Password:
Login succeeded</screen>
			<simpara>
				Push the chart to your local Quay repository using the <literal>helm chart push</literal> command:
			</simpara>
			
<screen>$ helm chart push example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4

The push refers to repository [example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad]
ref:     example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4
digest:  ce0233fd014992b8e27cc648cdabbebd4dd6850aca8fb8e50f7eef6f2f49833d
size:    3.5 KiB
name:    etherpad
version: 0.0.4
0.0.4: pushed to remote (1 layer, 3.5 KiB total)</screen>
			<simpara>
				To test that the push worked, delete the local copy and then pull the chart from the repository:
			</simpara>
			
<screen>$ helm chart rm example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4
$ rm -rf etherpad
$ helm chart pull example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4

0.0.4: Pulling from example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad
ref:     example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4
digest:  6850d9b21dd4b87cf20ad49f2e2c7def9655c52ea573e1ddb9d1464eeb6a46a6
size:    3.5 KiB
name:    etherpad
version: 0.0.4
Status: Downloaded newer chart for example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4</screen>
			<simpara>
				Use the <literal>helm chart export</literal> command to extract the chart files:
			</simpara>
			
<screen>$ helm chart export example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4

ref:     example-registry-quay-quay-enterprise.apps.user1.example.com/helm/etherpad:0.0.4
digest:  ce0233fd014992b8e27cc648cdabbebd4dd6850aca8fb8e50f7eef6f2f49833d
size:    3.5 KiB
name:    etherpad
version: 0.0.4
Exported chart to etherpad/</screen>
		</section>
		<section xml:id="config-fields-helm-oci">
			<title>OCI and Helm configuration</title>
			<simpara>
				Support for Helm and OCI artifacts is now enabled by default in Red Hat Quay 3.6. If you need to explicitly enable the feature, for example, if it has previously been disabled or if you have upgraded from a version where it is not enabled by default, you need to add two properties in the Quay configuration to enable the use of OCI artifacts:
			</simpara>
			
<programlisting language="yaml" linenumbering="unnumbered">FEATURE_GENERAL_OCI_SUPPORT: true
FEATURE_HELM_OCI_SUPPORT: true</programlisting>
			<table colsep="1" frame="all" rowsep="1">
				<title>OCI and Helm configuration</title>
				<tgroup cols="3">
					<colspec colname="col_1" colwidth="50*"></colspec>
					<colspec colname="col_2" colwidth="17*"></colspec>
					<colspec colname="col_3" colwidth="33*"></colspec>
					<thead>
						<row>
							<entry align="left" valign="top">Field</entry>
							<entry align="left" valign="top">Type</entry>
							<entry align="left" valign="top">Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry align="left" valign="top">
							<simpara>
								<emphasis role="strong">FEATURE_GENERAL_OCI_SUPPORT</emphasis>
							</simpara>
							</entry>
							<entry align="left" valign="top">
							<simpara>
								Boolean
							</simpara>
							</entry>
							<entry align="left" valign="top">
							<simpara>
								Enable support for OCI artifacts<?asciidoc-br ?><?asciidoc-br ?><emphasis role="strong">Default:</emphasis> True
							</simpara>
							</entry>
						</row>
						<row>
							<entry align="left" valign="top">
							<simpara>
								<emphasis role="strong">FEATURE_HELM_OCI_SUPPORT</emphasis>
							</simpara>
							</entry>
							<entry align="left" valign="top">
							<simpara>
								Boolean
							</simpara>
							</entry>
							<entry align="left" valign="top">
							<simpara>
								Enable support for Helm artifacts<?asciidoc-br ?><?asciidoc-br ?><emphasis role="strong">Default:</emphasis> True
							</simpara>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<important>
				<simpara>
					As of Red Hat Quay 3.6, <literal>FEATURE_HELM_OCI_SUPPORT</literal> has been deprecated and will be removed in a future version of Red Hat Quay. In Red Hat Quay 3.6, Helm artifacts are supported by default, and users will no longer be required to update their config.yaml files to enable support.
				</simpara>
			</important>
		</section>
		<section xml:id="cosign-oci-intro">
			<title>Cosign OCI support with Red Hat Quay</title>
			<simpara>
				Cosign is a tool that can be used to sign and verify container images. It uses the ECDSA-P256 signature algorithm and Red Hat’s Simple Signing payload format to create public keys that are stored in PKIX files. Private keys that are stored as encrypted PEM files.
			</simpara>
			<simpara>
				Cosign currently supports the following:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						Hardware and KMS Signing
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Bring-your-own PKI
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						OIDC PKI
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Built-in binary transparency and timestamping service
					</simpara>
				</listitem>
			</itemizedlist>
		</section>
		<section xml:id="cosign-oci-with-quay">
			<title>Using cosign with quay</title>
			<simpara>
				If you have Go 1.16+, you can directly install cosign with the following command:
			</simpara>
			
<literallayout class="monospaced">$ go install github.com/sigstore/cosign/cmd/cosign@v1.0.0
go: downloading github.com/sigstore/cosign v1.0.0
go: downloading github.com/peterbourgon/ff/v3 v3.1.0
...</literallayout>
			<simpara>
				Next, generate a keypair:
			</simpara>
			
<literallayout class="monospaced">$ cosign generate-key-pair
Enter password for private key:
Enter again:
Private key written to cosign.key
Public key written to cosign.pub</literallayout>
			<simpara>
				Sign the keypair with the following command:
			</simpara>
			
<literallayout class="monospaced">$ cosign sign -key cosign.key quay-server.example.com/user1/busybox:test
Enter password for private key:
Pushing signature to: quay-server.example.com/user1/busybox:sha256-ff13b8f6f289b92ec2913fa57c5dd0a874c3a7f8f149aabee50e3d01546473e3.sig</literallayout>
			<simpara>
				Some users may experience the following error:
			</simpara>
			
<literallayout class="monospaced">error: signing quay-server.example.com/user1/busybox:test: getting remote image: GET https://quay-server.example.com/v2/user1/busybox/manifests/test: UNAUTHORIZED: access to the requested resource is not authorized; map[]</literallayout>
			<simpara>
				Because cosign relies on ~/.docker/config.json for authorization, you might need to execute the following command:
			</simpara>
			
<literallayout class="monospaced">$ podman login --authfile ~/.docker/config.json quay-server.example.com
Username:
Password:
Login Succeeded!</literallayout>
			<simpara>
				You can ensure you are logged in with the following command:
			</simpara>
			
<literallayout class="monospaced">$ cat ~/.docker/config.json
{
	"auths": {
		"quay-server.example.com": {
			"auth": "cXVheWFkbWluOnBhc3N3b3Jk"
		}
	}</literallayout>
		</section>
		<section xml:id="other-oci-artifacts-with-quay">
			<title>Adding other OCI media types to Quay</title>
			<simpara>
				Helm, cosign, and ztsd compression scheme artifacts are built into Red Hat Quay 3.6 by default. For any other OCI media type that is not supported by default, you can add them to the <literal>ALLOWED_OCI_ARTIFACT_TYPES</literal> configuration in Quay’s config.yaml using the following format:
			</simpara>
			
<literallayout class="monospaced">ALLOWED_OCI_ARTIFACT_TYPES:
  &lt;oci config type 1&gt;:
  - &lt;oci layer type 1&gt;
  - &lt;oci layer type 2&gt;

  &lt;oci config type 2&gt;:
  - &lt;oci layer type 3&gt;
  - &lt;oci layer type 4&gt;
...</literallayout>
			<simpara>
				For example, you can add Singularity (SIF) support by adding the following to your config.yaml:
			</simpara>
			
<literallayout class="monospaced">...
ALLOWED_OCI_ARTIFACT_TYPES:
  application/vnd.oci.image.config.v1+json
  - application/vnd.oci.image.layer.v1.tar+zstd
  application/vnd.oci.image.config.v1+json
  - application/vnd.dev.cosign.simplesigning.v1+json
  application/vnd.cncf.helm.config.v1+json
  - application/tar+gzip
  application/vnd.sylabs.sif.config.v1+json
  - application/vnd.sylabs.sif.layer.v1+tar
...</literallayout>
			<note>
				<simpara>
					When adding OCI media types that are not supported by default, users will also need to manually add support for cosign and helm if desired. The ztsd compression scheme is hard-coded, so users will not need to add that OCI media type to their config.yaml.
				</simpara>
			</note>
			<simpara>
				Alternatively, if you want to disable OCI artifact support, you can set <literal>FEATURE_GENERAL_OCI_SUPPORT</literal> to <literal>False</literal> in your config.yaml:
			</simpara>
			
<literallayout class="monospaced">...
FEATURE_GENERAL_OCI_SUPPORT = False
...</literallayout>
		</section>
	</chapter>
	<chapter remap="_using_the_red_hat_quay_api" xml:id="using_the_red_hat_quay_api">
		<title>Using the Red Hat Quay API</title>
		<simpara xml:id="using-the-api">
			Red Hat Quay provides a full <link xlink:href="https://oauth.net/2/">OAuth 2</link>, RESTful API that:
		</simpara>
		<itemizedlist>
			<listitem>
				<simpara>
					Is available from endpoints of each Red Hat Quay instance from the URL <link xlink:href="https://&lt;yourquayhost&gt;/api/v1">https://&lt;yourquayhost&gt;/api/v1</link>
				</simpara>
			</listitem>
			<listitem>
				<simpara>
					Lets you connect to endpoints, via a browser, to get, delete, post, and put Red Hat Quay settings by enabling the Swagger UI
				</simpara>
			</listitem>
			<listitem>
				<simpara>
					Can be accessed by applications that make API calls and use OAuth tokens
				</simpara>
			</listitem>
			<listitem>
				<simpara>
					Sends and receives data as JSON
				</simpara>
			</listitem>
		</itemizedlist>
		<simpara>
			The following text describes how to access the Red Hat Quay API and use it to view and modify setting in your Red Hat Quay cluster. Appendix A lists and describes API endpoints.
		</simpara>
		<section remap="_accessing_the_quay_api_from_quay_io" xml:id="accessing_the_quay_api_from_quay_io">
			<title>Accessing the Quay API from Quay.io</title>
			<simpara>
				If you don’t have your own Red Hat Quay cluster running yet, you can explore the Red Hat Quay API available from Quay.io from your web browser:
			</simpara>
			
<screen>https://docs.quay.io/api/swagger/</screen>
			<simpara>
				The API Explorer that appears shows Quay.io API endpoints. You will not see superuser API endpoints or endpoints for Red Hat Quay features that are not enabled on Quay.io (such as Repository Mirroring).
			</simpara>
			<simpara>
				From API Explorer, you can get, and sometimes change, information on:
			</simpara>
			<itemizedlist>
				<listitem>
					<simpara>
						Billing, subscriptions, and plans
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Repository builds and build triggers
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Error messages and global messages
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Repository images, manifests, permissions, notifications, vulnerabilities, and image signing
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Usage logs
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Organizations, members and OAuth applications
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						User and robot accounts
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						and more…​
					</simpara>
				</listitem>
			</itemizedlist>
			<simpara>
				Select to open an endpoint to view the Model Schema for each part of the endpoint. Open an endpoint, enter any required parameters (such as a repository name or image), then select the <literal>Try it out!</literal> button to query or change settings associated with a Quay.io endpoint.
			</simpara>
		</section>
		<section remap="_create_oauth_access_token" xml:id="create_oauth_access_token">
			<title>Create OAuth access token</title>
			<simpara>
				To create an OAuth access token so you can access the API for your organization:
			</simpara>
			<orderedlist numeration="arabic">
				<listitem>
					<simpara>
						Log in to Red Hat Quay and select your Organization (or create a new one).
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select the Applications icon from the left navigation.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select Create New Application and give the new application a name when prompted.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select the new application.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select Generate Token from the left navigation.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Select the checkboxes to set the scope of the token and select Generate Access Token.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Review the permissions you are allowing and select Authorize Application to approve it.
					</simpara>
				</listitem>
				<listitem>
					<simpara>
						Copy the newly generated token to use to access the API.
					</simpara>
				</listitem>
			</orderedlist>
		</section>
		<section remap="_accessing_your_quay_api_from_a_web_browser" xml:id="accessing_your_quay_api_from_a_web_browser">
			<title>Accessing your Quay API from a web browser</title>
			<simpara>
				By enabling Swagger, you can access the API for your own Red Hat Quay instance through a web browser. This URL exposes the Red Hat Quay API explorer via the Swagger UI and this URL:
			</simpara>
			
<screen>https://&lt;yourquayhost&gt;/api/v1/discovery.</screen>
			<simpara>
				That way of accessing the API does not include superuser endpoints that are available on Red Hat Quay installations. Here is an example of accessing a Red Hat Quay API interface running on the local system by running the swagger-ui container image:
			</simpara>
			
<screen># export SERVER_HOSTNAME=&lt;yourhostname&gt;
# sudo podman run -p 8888:8080 -e API_URL=https://$SERVER_HOSTNAME:8443/api/v1/discovery docker.io/swaggerapi/swagger-ui</screen>
			<simpara>
				With the swagger-ui container running, open your web browser to localhost port 8888 to view API endpoints via the swagger-ui container.
			</simpara>
			<simpara>
				To avoid errors in the log such as "API calls must be invoked with an X-Requested-With header if called from a browser," add the following line to the <literal>config.yaml</literal> on all nodes in the cluster and restart Red Hat Quay:
			</simpara>
			
<screen>BROWSER_API_CALLS_XHR_ONLY: false</screen>
		</section>
		<section remap="_accessing_the_red_hat_quay_api_from_the_command_line" xml:id="accessing_the_red_hat_quay_api_from_the_command_line">
			<title>Accessing the Red Hat Quay API from the command line</title>
			<simpara>
				You can use the <literal>curl</literal> command to GET, PUT, POST, or DELETE settings via the API for your Red Hat Quay cluster. Replace <literal>&lt;token&gt;</literal> with the OAuth access token you created earlier to get or change settings in the following examples.
			</simpara>
			<section remap="_get_superuser_information" xml:id="get_superuser_information">
				<title>Get superuser information</title>
				
<screen>$ curl -X GET -H "Authorization: Bearer &lt;token_here&gt;" \
    "https://&lt;yourquayhost&gt;/api/v1/superuser/users/"</screen>
				<simpara>
					For example:
				</simpara>
				
<programlisting language="json" linenumbering="unnumbered">$ curl -X GET -H "Authorization: Bearer mFCdgS7SAIoMcnTsHCGx23vcNsTgziAa4CmmHIsg" http://quay-server:8080/api/v1/superuser/users/ | jq

{
  "users": [
    {
      "kind": "user",
      "name": "quayadmin",
      "username": "quayadmin",
      "email": "quayadmin@example.com",
      "verified": true,
      "avatar": {
        "name": "quayadmin",
        "hash": "357a20e8c56e69d6f9734d23ef9517e8",
        "color": "#5254a3",
        "kind": "user"
      },
      "super_user": true,
      "enabled": true
    }
  ]
}</programlisting>
			</section>
			<section remap="_creating_a_superuser_using_the_api" xml:id="creating_a_superuser_using_the_api">
				<title>Creating a superuser using the API</title>
				<itemizedlist>
					<listitem>
						<simpara>
							Configure a superuser name, as described in the Deploy Quay book:
						</simpara>
						<itemizedlist>
							<listitem>
								<simpara>
									Use the configuration editor UI or
								</simpara>
							</listitem>
							<listitem>
								<simpara>
									Edit the <literal>config.yaml</literal> file directly, with the option of using the configuration API to validate (and download) the updated configuration bundle
								</simpara>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<simpara>
							Create the user account for the superuser name:
						</simpara>
						<itemizedlist>
							<listitem>
								<simpara>
									Obtain an authorization token as detailed above, and use <literal>curl</literal> to create the user:
								</simpara>
								
<screen>$ curl -H "Content-Type: application/json"  -H "Authorization: Bearer Fava2kV9C92p1eXnMawBZx9vTqVnksvwNm0ckFKZ" -X POST --data '{
 "username": "quaysuper",
 "email": "quaysuper@example.com"
}'  http://quay-server:8080/api/v1/superuser/users/ | jq</screen>
							</listitem>
							<listitem>
								<simpara>
									The returned content includes a generated password for the new user account:
								</simpara>
								
<programlisting language="json" linenumbering="unnumbered">{
  "username": "quaysuper",
  "email": "quaysuper@example.com",
  "password": "EH67NB3Y6PTBED8H0HC6UVHGGGA3ODSE",
  "encrypted_password": "fn37AZAUQH0PTsU+vlO9lS0QxPW9A/boXL4ovZjIFtlUPrBz9i4j9UDOqMjuxQ/0HTfy38goKEpG8zYXVeQh3lOFzuOjSvKic2Vq7xdtQsU="
}</programlisting>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>
				<simpara>
					Now, when you request the list of users , it will show <literal>quaysuper</literal> as a superuser:
				</simpara>
				
<programlisting language="json" linenumbering="unnumbered">$ curl -X GET -H "Authorization: Bearer mFCdgS7SAIoMcnTsHCGx23vcNsTgziAa4CmmHIsg" http://quay-server:8080/api/v1/superuser/users/ | jq

{
  "users": [
  {
      "kind": "user",
      "name": "quayadmin",
      "username": "quayadmin",
      "email": "quayadmin@example.com",
      "verified": true,
      "avatar": {
        "name": "quayadmin",
        "hash": "357a20e8c56e69d6f9734d23ef9517e8",
        "color": "#5254a3",
        "kind": "user"
      },
      "super_user": true,
      "enabled": true
    },
    {
      "kind": "user",
      "name": "quaysuper",
      "username": "quaysuper",
      "email": "quaysuper@example.com",
      "verified": true,
      "avatar": {
        "name": "quaysuper",
        "hash": "c0e0f155afcef68e58a42243b153df08",
        "color": "#969696",
        "kind": "user"
      },
      "super_user": true,
      "enabled": true
    }
  ]
}</programlisting>
			</section>
			<section remap="_directory_synchronization" xml:id="directory_synchronization">
				<title>Directory synchronization</title>
				<simpara>
					To enable directory synchronization for the team <literal>newteam</literal> in organization <literal>testadminorg</literal>, where the corresponding group name in LDAP is <literal>ldapgroup</literal>:
				</simpara>
				
<screen>$ curl -X POST -H "Authorization: Bearer 9rJYBR3v3pXcj5XqIA2XX6Thkwk4gld4TCYLLWDF" \
       -H "Content-type: application/json" \
       -d '{"group_dn": "cn=ldapgroup,ou=Users"}' \
       http://quay1-server:8080/api/v1/organization/testadminorg/team/newteam/syncing</screen>
				<simpara>
					To disable synchronization for the same team:
				</simpara>
				
<screen>$ curl -X DELETE -H "Authorization: Bearer 9rJYBR3v3pXcj5XqIA2XX6Thkwk4gld4TCYLLWDF" \
       http://quay1-server:8080/api/v1/organization/testadminorg/team/newteam/syncing</screen>
			</section>
			<section remap="_create_a_repository_build_via_api" xml:id="create_a_repository_build_via_api">
				<title>Create a repository build via API</title>
				<simpara>
					In order to build a repository from the specified input and tag the build with custom tags, users can use requestRepoBuild endpoint. It takes the following data:
				</simpara>
				
<screen>{
"docker_tags": [
   "string"
],
"pull_robot": "string",
"subdirectory": "string",
"archive_url": "string"
}</screen>
				<simpara>
					The <literal>archive_url</literal> parameter should point to a <literal>tar</literal> or <literal>zip</literal> archive that includes the Dockerfile and other required files for the build. The <literal>file_id</literal> parameter was apart of our older build system. It cannot be used anymore. If Dockerfile is in a sub-directory it needs to be specified as well.
				</simpara>
				<simpara>
					The archive should be publicly accessible. OAuth app should have "Administer Organization" scope because only organization admins have access to the robots' account tokens. Otherwise, someone could get robot permissions by simply granting a build access to a robot (without having access themselves), and use it to grab the image contents. In case of errors, check the json block returned and ensure the archive location, pull robot, and other parameters are being passed correctly. Click "Download logs" on the top-right of the individual build’s page to check the logs for more verbose messaging.
				</simpara>
			</section>
			<section remap="_create_an_org_robot" xml:id="create_an_org_robot">
				<title>Create an org robot</title>
				
<screen>$ curl -X PUT https://quay.io/api/v1/organization/{orgname}/robots/{robot shortname} \
   -H 'Authorization: Bearer &lt;token&gt;''</screen>
			</section>
			<section remap="_trigger_a_build" xml:id="trigger_a_build">
				<title>Trigger a build</title>
				
<screen>$ curl -X POST https://quay.io/api/v1/repository/YOURORGNAME/YOURREPONAME/build/ \
   -H 'Authorization: Bearer &lt;token&gt;'</screen>
				<simpara>
					Python with requests
				</simpara>
				
<screen>import requests
r = requests.post('https://quay.io/api/v1/repository/example/example/image', headers={'content-type': 'application/json', 'Authorization': 'Bearer &lt;redacted&gt;'}, data={[&lt;request-body-contents&gt;})
print(r.text)</screen>
			</section>
			<section remap="_create_a_private_repository" xml:id="create_a_private_repository">
				<title>Create a private repository</title>
				
<screen>$ curl -X POST https://quay.io/api/v1/repository \
    -H 'Authorization: Bearer {token}' \
    -H 'Content-Type: application/json' \
    -d '{"namespace":"yournamespace", "repository":"yourreponame",
    "description":"descriptionofyourrepo", "visibility": "private"}' | jq</screen>
			</section>
		</section>
	</chapter>
</book>


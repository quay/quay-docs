<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="chrometwo"><head><title>Red Hat Quay Architecture</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css"/><meta name="generator" content="publican v4.3.2"/><meta name="description" content="Red Hat Quay Architecture"/><link rel="next" href="#arch-intro" title="Chapter 1. Red Hat Quay features"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><script type="text/javascript" src="Common_Content/scripts/jquery-1.7.1.min.js"> </script><script type="text/javascript" src="Common_Content/scripts/utils.js"> </script><script type="text/javascript" src="Common_Content/scripts/highlight.js/highlight.pack.js"> </script></head><body><div id="chrometwo"><div id="main"><div xml:lang="en-US" class="book" id="idm45976368570480"><div class="titlepage"><div><div class="producttitle"><span class="productname">Red Hat Quay</span> <span class="productnumber">3.5</span></div><div><h1 class="title">Red Hat Quay Architecture</h1></div><div><h2 class="subtitle">Red Hat Quay Architecture</h2></div><div><div xml:lang="en-US" class="authorgroup"><span class="orgname">Red Hat OpenShift Documentation Team</span></div></div><div><a href="#idm45976349527728">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
				Red Hat Quay Architecture
			</div></div></div></div><hr/></div><div class="toc"><ul class="toc"><li><span class="chapter"><a href="#arch-intro">1. Red Hat Quay features</a></span></li><li><span class="chapter"><a href="#arch-core-intro">2. Core functionality</a></span><ul><li><span class="section"><a href="#infrastructure">2.1. Infrastructure</a></span><ul><li><span class="section"><a href="#running_quay_on_standalone_hosts">2.1.1. Running Quay on standalone hosts</a></span></li><li><span class="section"><a href="#running_quay_on_openshift">2.1.2. Running Quay on OpenShift</a></span></li><li><span class="section"><a href="#running_quay_with_openshift">2.1.3. Running Quay with OpenShift</a></span></li><li><span class="section"><a href="#benefits_of_running_quay_on_openshift">2.1.4. Benefits of running Quay on OpenShift</a></span></li><li><span class="section"><a href="#core-distinct-registries">2.1.5. Single versus multiple registries</a></span></li></ul></li><li><span class="section"><a href="#core-prereqs">2.2. Quay prerequisites</a></span><ul><li><span class="section"><a href="#core-prereqs-storage">2.2.1. Image storage backend</a></span></li><li><span class="section"><a href="#core-prereqs-db">2.2.2. Database backend</a></span></li><li><span class="section"><a href="#core-prereqs-redis">2.2.3. Redis</a></span></li></ul></li><li><span class="section"><a href="#quay_on_public_cloud">2.3. Quay on public cloud</a></span><ul><li><span class="section"><a href="#running_red_hat_quay_on_aws">2.3.1. Running Red Hat Quay on AWS</a></span></li><li><span class="section"><a href="#running_red_hat_quay_on_microsoft_azure">2.3.2. Running Red Hat Quay on Microsoft Azure</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#security-intro">3. Security Overview</a></span><ul><li><span class="section"><a href="#clair-intro">3.1. Red Hat Quay vulnerability scanning using Clair</a></span><ul><li><span class="section"><a href="#clair-analyses">3.1.1. Understanding Clair analyses</a></span></li><li><span class="section"><a href="#clairv4-intro">3.1.2. Clair v4</a></span></li><li><span class="section"><a href="#clairv4-arch">3.1.3. Clair v4 architecture</a></span></li><li><span class="section"><a href="#clairv2-to-v4">3.1.4. Migrating from Clair v2 to Clair v4</a></span></li><li><span class="section"><a href="#clairv4-limitations">3.1.5. Clair v4 limitations</a></span></li><li><span class="section"><a href="#clairv4-air-gapped">3.1.6. Air-gapped Clair v4</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#content-distrib-intro">4. Content distribution</a></span><ul><li><span class="section"><a href="#mirroring-intro">4.1. Repository mirroring</a></span><ul><li><span class="section"><a href="#mirroring-using">4.1.1. Using repository mirroring</a></span></li><li><span class="section"><a href="#mirroring-recommend">4.1.2. Repository mirroring recommendations</a></span></li><li><span class="section"><a href="#mirroring-events">4.1.3. Event notifications for mirroring</a></span></li><li><span class="section"><a href="#mirroring-api-intro">4.1.4. Mirroring API</a></span></li></ul></li><li><span class="section"><a href="#georepl-intro">4.2. Geo-replication</a></span><ul><li><span class="section"><a href="#geo_replication_features">4.2.1. Geo-replication features</a></span></li><li><span class="section"><a href="#georepl-prereqs">4.2.2. Geo-replication requirements and constraints</a></span></li><li><span class="section"><a href="#georepl-arch">4.2.3. Geo-replication architecture</a></span></li><li><span class="section"><a href="#georepl-mixed-storage">4.2.4. Mixed storage for geo-replication</a></span></li></ul></li><li><span class="section"><a href="#mirroring-versus-georepl">4.3. Repository mirroring versus geo-replication</a></span></li><li><span class="section"><a href="#airgap-intro">4.4. Air-gapped / disconnected deployments</a></span><ul><li><span class="section"><a href="#airgap-clair">4.4.1. Using Clair in air-gapped environments</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#access-control-intro">5. Access control</a></span><ul><li><span class="section"><a href="#repository-organizations-and-users">5.1. Repository organizations and users</a></span><ul><li><span class="section"><a href="#quay-users">5.1.1. Red Hat Quay users</a></span></li><li><span class="section"><a href="#quay-robot-accounts">5.1.2. Red Hat Quay robot accounts</a></span></li><li><span class="section"><a href="#quay-super-users">5.1.3. Red Hat Quay Super users</a></span></li></ul></li><li><span class="section"><a href="#permissions">5.2. Permissions</a></span><ul><li><span class="section"><a href="#role-based-access-control">5.2.1. Role Based Access Control (RBAC)</a></span></li><li><span class="section"><a href="#fine-grained-access-control">5.2.2. Fine Grained Access Control</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#sizing-intro">6. Sizing</a></span><ul><li><span class="section"><a href="#quay-sample-sizings-intro">6.1. Red Hat Quay Sample Sizings</a></span></li><li><span class="section"><a href="#sample-quay-on-prem-intro">6.2. Sample Red Hat Quay on-premises configuration</a></span></li><li><span class="section"><a href="#quay-subscription-intro">6.3. Red Hat Quay subscription information</a></span></li><li><span class="section"><a href="#quay-example-deployment">6.4. Red Hat Quay example deployments</a></span></li><li><span class="section"><a href="#quay-internal-registry-intro">6.5. Using Red Hat Quay with or without internal registry</a></span></li><li><span class="section"><a href="#quay-deployment-topology">6.6. Red Hat Quay deployment topology</a></span></li><li><span class="section"><a href="#quay-deployment-topology-with-storage-proxy">6.7. Red Hat Quay deployment topology with storage proxy</a></span></li></ul></li><li><span class="chapter"><a href="#scalability-intro">7. Scalability</a></span></li><li><span class="chapter"><a href="#build-automation-intro">8. Build automation</a></span></li><li><span class="chapter"><a href="#integration-intro">9. Integration</a></span></li></ul></div><section class="chapter" id="arch-intro"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Red Hat Quay features</h1></div></div></div><p>
			Red Hat Quay is a trusted, open source container registry platform that runs everywhere, but runs best on Red Hat OpenShift. It scales without limits, from a developer laptop to a container host or Kubernetes, and can be deployed on-premise or on public cloud. It provides global governance and security controls, with features including image vulnerability scanning, access controls, geo-replication and repository mirroring.
		</p><p>
			<span class="inlinemediaobject"><img src="images/quay-features.png" alt="Quay features"/></span>
		</p><p>
			This guide provides an insight into architectural patterns to use when deploying Red Hat Quay. It contains sizing guidance and deployment prerequisites, along with best practices for ensuring high availability for your Quay registry.
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<a class="link" href="#arch-core-intro" title="Chapter 2. Core functionality">Core functionality</a>
				</li><li class="listitem">
					<a class="link" href="#security-intro" title="Chapter 3. Security Overview">Security</a>
				</li><li class="listitem">
					<a class="link" href="#content-distrib-intro" title="Chapter 4. Content distribution">Content distribution</a>
				</li><li class="listitem">
					<a class="link" href="#access-control-intro" title="Chapter 5. Access control">Access control</a>
				</li><li class="listitem">
					<a class="link" href="#build-automation-intro" title="Chapter 8. Build automation">Build automation</a>
				</li><li class="listitem">
					<a class="link" href="#scalability-intro" title="Chapter 7. Scalability">Scalability</a>
				</li><li class="listitem">
					<a class="link" href="#integration-intro" title="Chapter 9. Integration">Integration</a>
				</li></ul></div></section><section class="chapter" id="arch-core-intro"><div class="titlepage"><div><div><h1 class="title">Chapter 2. Core functionality</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					High availability
				</li><li class="listitem">
					Full standards / spec support
				</li><li class="listitem">
					Long-Term protocol support
				</li><li class="listitem">
					OCI compatibility
				</li><li class="listitem">
					Enterprise grade support
				</li><li class="listitem">
					Regular updates
				</li></ul></div><section class="section" id="infrastructure"><div class="titlepage"><div><div><h2 class="title">2.1. Infrastructure</h2></div></div></div><p>
				Quay runs on any physical or virtual infrastructure, both on-premise or public cloud. Deployments range from simple to massively scaled, including:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						All-in-one setup on a developer laptop
					</li><li class="listitem">
						Highly available on OpenShift
					</li><li class="listitem">
						Geographically dispersed setup across multiple availability zones and regions
					</li></ul></div><section class="section" id="running_quay_on_standalone_hosts"><div class="titlepage"><div><div><h3 class="title">2.1.1. Running Quay on standalone hosts</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Poof-of-concept deployment, where Quay runs on the same machine as the image storage, database, Redis and optionally, Clair security scanning
						</li><li class="listitem">
							Highly available setups running on multiple hosts, using <code class="literal">systemd</code> to ensure restart on failure/reboot
						</li></ul></div><p>
					Standalone deployment is typically a manual process, but it can be automated using Ansible. All standalone hosts require valid RHEL subscriptions.
				</p></section><section class="section" id="running_quay_on_openshift"><div class="titlepage"><div><div><h3 class="title">2.1.2. Running Quay on OpenShift</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Automated deployment and Day 2 management of Red Hat Quay with customization options
						</li><li class="listitem">
							Quay Operator can manage Quay and all dependencies
						</li><li class="listitem">
							Automated scaling and updates
						</li><li class="listitem">
							Integration with existing OpenShift processes like GitOps, monitoring, alerting, logging
						</li></ul></div><p>
					Quay can run on OpenShift infra nodes, meaning no further subscriptions are required.
				</p></section><section class="section" id="running_quay_with_openshift"><div class="titlepage"><div><div><h3 class="title">2.1.3. Running Quay with OpenShift</h3></div></div></div><p>
					While the Quay Operator ensures seamless deployment and management of Quay running on OpenShift, it is also possible to run Quay in standalone mode and then serve content to one or many OpenShift clusters, wherever they are running. A number of operators are available to help integrate standalone Quay with OpenShift:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<span class="strong strong"><strong>Quay Cluster Security Operator:</strong></span> brings Quay / Clair vulnerability data into the OpenShift Console
						</li><li class="listitem">
							<span class="strong strong"><strong>Quay Bridge Operator:</strong></span> ensures seamless integration and user experience for using Quay with OpenShift
						</li></ul></div></section><section class="section" id="benefits_of_running_quay_on_openshift"><div class="titlepage"><div><div><h3 class="title">2.1.4. Benefits of running Quay on OpenShift</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<span class="strong strong"><strong>Zero to Hero:</strong></span> Simplified deployment of Quay and associated components means that you can start using the product immediately
						</li><li class="listitem">
							<span class="strong strong"><strong>Scalability:</strong></span> Leverage cluster compute capacity to manage expected demand
						</li><li class="listitem">
							<span class="strong strong"><strong>Simplified Networking:</strong></span> Diverse ingress options using well established patterns for any application deployed on the platform
						</li><li class="listitem">
							<span class="strong strong"><strong>Centralized configuration management:</strong></span> Configurations stored in <code class="literal">etcd</code> provide a centralized source of truth
						</li><li class="listitem">
							<span class="strong strong"><strong>Repeatability:</strong></span> Consistency regardless of the number of replicas of Quay / Clair
						</li><li class="listitem">
							<span class="strong strong"><strong>Expanded Options:</strong></span> Additional solutions that are specifically designed to take advantage of an OpenShift deployment
						</li></ul></div></section><section class="section" id="core-distinct-registries"><div class="titlepage"><div><div><h3 class="title">2.1.5. Single versus multiple registries</h3></div></div></div><p>
					Many users consider running multiple, distinct registries while the preferred approach with Quay is to have a single, shared registry. The following table addresses the reasons why a user might want to run multiple registries and how these requirements are addressed in Quay:
				</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 50%; " class="col_2"/></colgroup><thead><tr><th align="left" valign="top" id="idm45976351860048" scope="col">Multiple registries</th><th align="left" valign="top" id="idm45976345768000" scope="col">Quay approach</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm45976351860048">
								<p>
									Clear separation between Dev and Prod
								</p>
								</td><td align="left" valign="top" headers="idm45976345768000">
								<p>
									Use organizations and repositories instead + RBAC Clear separation by content origin<br/> (internal/external)
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm45976351860048">
								<p>
									Use organizations and repositories instead + RBAC Required to test registry upgrades given the criticality of the registry for running apps
								</p>
								</td><td align="left" valign="top" headers="idm45976345768000">
								<p>
									Updates and upgrades are tested by Quay QE<br/> (When Quay Operator facilitates updates, they will become even more frictionless)
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm45976351860048">
								<p>
									Separate registry in each datacenter (DC)
								</p>
								</td><td align="left" valign="top" headers="idm45976345768000">
								<p>
									Quay can serve content to multiple DCs, HA can stretch across DCs
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm45976351860048">
								<p>
									Separate registry for each cluster
								</p>
								</td><td align="left" valign="top" headers="idm45976345768000">
								<p>
									Quay can serve content to thousands of clusters
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm45976351860048">
								<p>
									Scalability concerns over single registry
								</p>
								</td><td align="left" valign="top" headers="idm45976345768000">
								<p>
									Quay scales nearly without limits<br/> (The underlying code base is proven to work at scale at Quay.io)
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm45976351860048">
								<p>
									Distinct registry configurations
								</p>
								</td><td align="left" valign="top" headers="idm45976345768000">
								<p>
									In this scenario it might make sense to run two distinct registries
								</p>
								</td></tr></tbody></table></div><p>
					<span class="strong strong"><strong>Recommendation:</strong></span>
				</p><p>
					Running a shared registry helps you to save storage, infrastructure and operational costs. A dedicated registry would be really needed in very specific circumstances.
				</p></section></section><section class="section" id="core-prereqs"><div class="titlepage"><div><div><h2 class="title">2.2. Quay prerequisites</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						<a class="link" href="#core-prereqs-db" title="2.2.2. Database backend">Database</a>
					</li><li class="listitem">
						<a class="link" href="#core-prereqs-storage" title="2.2.1. Image storage backend">Image storage</a>
					</li><li class="listitem">
						<a class="link" href="#core-prereqs-redis" title="2.2.3. Redis">Redis</a>
					</li></ul></div><section class="section" id="core-prereqs-storage"><div class="titlepage"><div><div><h3 class="title">2.2.1. Image storage backend</h3></div></div></div><p>
					Quay stores all binary blobs in its storage backend
				</p><p>
					Local storage and NFS only for PoC / test setups
				</p><p>
					Quay HA requires an HA storage setup
				</p><p>
					Geo-replication requires object storage and does not work with local storage
				</p><section class="section" id="supported_on_prem_storage_types"><div class="titlepage"><div><div><h4 class="title">2.2.1.1. Supported on-prem storage types</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Ceph Rados RGW
							</li><li class="listitem">
								OpenStack Swift
							</li><li class="listitem">
								RHODF 4 (via NooBaa)
							</li><li class="listitem">
								RHOCS 3 (via NooBaa) (TP) TODO Check
							</li></ul></div></section><section class="section" id="supported_public_cloud_storage_types"><div class="titlepage"><div><div><h4 class="title">2.2.1.2. Supported public cloud storage types</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								AWS S3
							</li><li class="listitem">
								Google Cloud Storage
							</li><li class="listitem">
								Azure Blob Storage
							</li></ul></div></section></section><section class="section" id="core-prereqs-db"><div class="titlepage"><div><div><h3 class="title">2.2.2. Database backend</h3></div></div></div><p>
					Quay stores most of its configuration and all metadata and logs inside its database backend. Logs can be pushed into ElasticSearch instead
				</p><p>
					PostgreSQL is the preferred database backend since it can be used for both Quay and Clair
				</p><p>
					Quay works fine with MySQL too (5.7+) but Clair requires PostgreSQL
				</p><p>
					Quay HA requires an HA database setup
				</p><p>
					If Quay is running on public cloud infrastructure, we recommend the use of the PostgreSQL services provided by your cloud provider.
				</p><p>
					Geo-replication requires a single, shared database that is accessible from all regions
				</p></section><section class="section" id="core-prereqs-redis"><div class="titlepage"><div><div><h3 class="title">2.2.3. Redis</h3></div></div></div><p>
					Quay stores builder logs inside a Redis cache. The data stored is ephemeral in nature and as such, Redis does not need to be HA even though it is stateful. if Redis does fail, you will only lose access to build logs.
				</p><p>
					You can use a Redis image from the Red Hat Software Collections or from any other source you prefer.
				</p></section></section><section class="section" id="quay_on_public_cloud"><div class="titlepage"><div><div><h2 class="title">2.3. Quay on public cloud</h2></div></div></div><p>
				Quay can run on public clouds, either in standalone mode or where OpenShift itself has been deployed on public cloud.
			</p><p>
				Recommendation: If Quay is running on public cloud, then you should use the public cloud services for Quay backend services to ensure proper HA and scalability
			</p><p>
				A full list of tested and supported configurations can be found in the Red Hat Quay Tested Integrations Matrix at <a class="link" href="https://access.redhat.com/articles/4067991">https://access.redhat.com/articles/4067991</a>
			</p><section class="section" id="running_red_hat_quay_on_aws"><div class="titlepage"><div><div><h3 class="title">2.3.1. Running Red Hat Quay on AWS</h3></div></div></div><p>
					<span class="inlinemediaobject"><img src="images/public-cloud-aws.png" alt="Red Hat Quay on AWS"/></span>
				</p><p>
					If Red Hat Quay is running on AWS, you can use
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							AWS Elastic Load Balancer
						</li><li class="listitem">
							AWS S3 (hot) blob storage
						</li><li class="listitem">
							AWS RDS database
						</li><li class="listitem">
							AWS ElastiCache Redis
						</li><li class="listitem">
							EC2 VMs recommendation: M3.Large or M4.XLarge
						</li></ul></div></section><section class="section" id="running_red_hat_quay_on_microsoft_azure"><div class="titlepage"><div><div><h3 class="title">2.3.2. Running Red Hat Quay on Microsoft Azure</h3></div></div></div><p>
					<span class="inlinemediaobject"><img src="images/public-cloud-azure.png" alt="Red Hat Quay on Microsoft Azure"/></span>
				</p><p>
					If Quay is running on Microsoft Azure, you can use:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Azure managed services such as HA PostgreSQL
						</li><li class="listitem">
							Azure Blob Storage must be hot storage (not Azure Cool Blob Storage)
						</li><li class="listitem">
							Azure Cache for Redis
						</li></ul></div></section></section></section><section class="chapter" id="security-intro"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Security Overview</h1></div></div></div><p>
			Red Hat Quay is built for real enterprise use cases where content governance and security are two major focus areas. Red Hat Quay content governance and security includes a built-in vulnerability scanning via Clair.
		</p><p>
			Clair is an open source tool developed by CoreOS for Quay that generates analyses of vulnerabilities in application containers, which currently includes Open Container Initiative (OCI) and Docker images. Clients that use the Clair API to index their container images can then match their images against known vulnerabilities.
		</p><p>
			Clair supports the extraction of contents and assignment of vulnerabilities from the following official base containers:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					Ubuntu Linux
				</li><li class="listitem">
					Debian Linux
				</li><li class="listitem">
					Red Hat Enterprise Linux
				</li><li class="listitem">
					SUSE
				</li><li class="listitem">
					Oracle Linux
				</li><li class="listitem">
					Alpine Linux
				</li><li class="listitem">
					Amazon Linux
				</li><li class="listitem">
					VMWare Photon
				</li><li class="listitem">
					Python
				</li></ul></div><section class="section" id="clair-intro"><div class="titlepage"><div><div><h2 class="title">3.1. Red Hat Quay vulnerability scanning using Clair</h2></div></div></div><p>
				Clair is equipped with three types of scanners, a matcher, and an updater:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						<span class="strong strong"><strong>Distribution Scanner</strong></span>: This scanner discovers <code class="literal">Distribution</code> information, which is typically the base operator system the layer demonstrates features of.
					</li><li class="listitem">
						<span class="strong strong"><strong>Package Scanner</strong></span>: This scanner performs a package scan on the selected layer and returns all of the found packages.
					</li><li class="listitem">
						<span class="strong strong"><strong>Repository Scanner</strong></span>: This scanner discovers any package repositories that are present in the layers.
					</li><li class="listitem">
						<span class="strong strong"><strong>Matcher</strong></span>: Matcher implementation is responsible for telling ClairCore which packages to query, how to query the security advisory database, and whether the discovered <code class="literal">Vulnerability</code> from the security advisory database affects the provided package.
					</li><li class="listitem">
						<span class="strong strong"><strong>Updater</strong></span>: The updater is responsible for fetching a security advisory database and parsing the contents.
					</li></ul></div><section class="section" id="clair-analyses"><div class="titlepage"><div><div><h3 class="title">3.1.1. Understanding Clair analyses</h3></div></div></div><p>
					Clair analyses can be broken down into three distinct parts:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Indexing</strong></span>: Indexing starts with submitting a <code class="literal">Manifest</code> to Clair. On receipt, Clair will fetch layers, scan their contents, and return an intermediate representation called an <code class="literal">IndexReport</code>.
						</p><p class="simpara">
							Manifests are Clair’s representation of a container image. Clair leverages the fact <code class="literal">OCI Manifests</code> and <code class="literal">Layers</code> are content-addressed to reduce duplicated work.
						</p><p class="simpara">
							Once a <code class="literal">Manifest</code> is indexed, the <code class="literal">IndexReport</code> is persisted for later retrieval.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Matching</strong></span>: Matching is taking an <code class="literal">IndexReport</code> and correlating vulnerabilities affecting the <code class="literal">Manifest</code> the report represents.
						</p><p class="simpara">
							Clair continuously ingests new security data and a request to the matcher will always provide users with the most to date vulnerability analysis of an <code class="literal">IndexReport</code>.
						</p></li><li class="listitem">
							<span class="strong strong"><strong>Notifications</strong></span>: Clair implements a notification service. When new vulnerabilities are discovered, the notifier service will determine if these vulnerabilities affect any indexed <code class="literal">Manifests</code>. The notifier will then take action according to its configuration.
						</li></ul></div><section class="section" id="notifications_for_vulnerabilities_found_by_clair"><div class="titlepage"><div><div><h4 class="title">3.1.1.1. Notifications for vulnerabilities found by Clair</h4></div></div></div><p>
						Red Hat Quay 3.4 triggers different notifications for various repository events. These notifications vary based on enabled features.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							This include the event type <code class="literal">Package Vulnerability Found</code>
						</p></div></div><p>
						<code class="literal">Additional Filter</code> can be applied for <code class="literal">Security Level</code>, and there are various notification methods. Custom notification titles are also optional.
					</p></section></section><section class="section" id="clairv4-intro"><div class="titlepage"><div><div><h3 class="title">3.1.2. Clair v4</h3></div></div></div><p>
					Released with Red Hat Quay 3.4, Clair v4 is the latest version of Clair. It is built on a new architecture consisting of Clair Core and a service wrapper. Clair v4 made several enhancements to Clair v2, including:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Support for the Python programming language package. Support for additional languages is planned for future versions of Clair and Red Hat Quay.
						</li><li class="listitem">
							Immutable data model and a new manifest-oriented API.
						</li><li class="listitem">
							Refocus on the latest Open Container Initiative (OCI) specifications.
						</li><li class="listitem">
							Image hashes and layer hashes are now treated as content addressable, so that images are uniquely identified as a whole.
						</li></ul></div></section><section class="section" id="clairv4-arch"><div class="titlepage"><div><div><h3 class="title">3.1.3. Clair v4 architecture</h3></div></div></div><p>
					Clair v4 utilizes the ClairCore library as its engine for examining contents and reporting vulnerabilities. At a high level you can consider Clair a service wrapper to the functionality provided in the ClairCore library.
				</p><section class="section" id="claircore"><div class="titlepage"><div><div><h4 class="title">3.1.3.1. ClairCore</h4></div></div></div><p>
						ClairCore is the engine behind Clair v4’s container security solution. The ClairCore package exports our domain models, interfaces necessary to plug into our business logic, and a default set of implementations. This default set of implementations defines our support matrix.
					</p><p>
						ClairCore relies on Postgres for its persistence and the library will handle migrations if configured to do so.
					</p><p>
						The diagram below is a high level overview of ClairCore’s architecture.
					</p><p>
						<span class="inlinemediaobject"><img src="images/clair-core-architecture.png" alt="Connection not secure"/></span>
					</p><p>
						When a <code class="literal">claircore.Manifest</code> is submitted to the LibIndex, the library will index its constituent parts and create a report with its findings.
					</p><p>
						When a <code class="literal">claircore.IndexReport</code> is provided to LibVuln, the library will discover vulnerabilities affecting it and generate a <code class="literal">claircore.Volunerability</code> report.
					</p><section class="section" id="clairv2-compare-v4"><div class="titlepage"><div><div><h5 class="title">3.1.3.1.1. Clair v2 and Clair v4 Comparison</h5></div></div></div><div class="table" id="idm45976346240480"><p class="title"><strong>Table 3.1. Clair v2 and Clair v4 component comparison</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 25%; " class="col_2"/><col style="width: 25%; " class="col_3"/></colgroup><thead><tr><th align="left" valign="top" id="idm45976346274656" scope="col">Component</th><th align="left" valign="top" id="idm45976346273440" scope="col">Clair v2</th><th align="left" valign="top" id="idm45976346258672" scope="col">Clair v4</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm45976346274656">
										<p>
											API layers
										</p>
										</td><td align="left" valign="top" headers="idm45976346273440">
										<p>
											In Clair v2, clients were required to provide layers to the API.
										</p>
										</td><td align="left" valign="top" headers="idm45976346258672">
										<p>
											Clair v4 is manifest-based, providing an easier API for users.
										</p>
										</td></tr><tr><td align="left" valign="top" headers="idm45976346274656">
										<p>
											Insights and reports
										</p>
										</td><td align="left" valign="top" headers="idm45976346273440">
										<p>
											Clair v2 provided only insights on vulnerabilities
										</p>
										</td><td align="left" valign="top" headers="idm45976346258672">
										<p>
											Clair v4 provides detailed reports on the content of the container, which can be fed to other tools for analyses or inventory purposes.
										</p>
										</td></tr><tr><td align="left" valign="top" headers="idm45976346274656">
										<p>
											Architecture
										</p>
										</td><td align="left" valign="top" headers="idm45976346273440">
										<p>
											Clair v2 ran as a monolithic application.
										</p>
										</td><td align="left" valign="top" headers="idm45976346258672">
										<p>
											Clair v4 divides functionality across multiple services for ease of development and scaling use cases.
										</p>
										</td></tr><tr><td align="left" valign="top" headers="idm45976346274656">
										<p>
											Support for language packages
										</p>
										</td><td align="left" valign="top" headers="idm45976346273440">
										<p>
											Clair v2 does not support computer language packages.
										</p>
										</td><td align="left" valign="top" headers="idm45976346258672">
										<p>
											Clair v4 supports Python language packages, with plans of adding more in future versions.
										</p>
										</td></tr><tr><td align="left" valign="top" headers="idm45976346274656">
										<p>
											Package locator
										</p>
										</td><td align="left" valign="top" headers="idm45976346273440">
										<p>
											Clair v2 did not provide details on where packages were located inside of the container.
										</p>
										</td><td align="left" valign="top" headers="idm45976346258672">
										<p>
											Clair v4 identifies where packages are located inside of the container.
										</p>
										</td></tr></tbody></table></div></div></section></section></section><section class="section" id="clairv2-to-v4"><div class="titlepage"><div><div><h3 class="title">3.1.4. Migrating from Clair v2 to Clair v4</h3></div></div></div><p>
					Starting with Red Hat Quay 3.4, Clair v4 will be used by default. It will also be the only version of Clair continually supported, as older Red Hat Quay versions are not supported with Clair v4 in production. Users should continue using Clair v2 if using a version of Red Hat Quay earlier than 3.4.
				</p><p>
					Existing Red Hat Quay 3.3 deployments will be upgraded to Clair v4 when managed via the Red Hat Quay Operator. Manually upgraded Red Hat Quay deployments can install Clair v4 side-by-side, which will cause the following:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							All new image vulnerability scans to be performed by Clair v4
						</li><li class="listitem">
							Existing images to be rescanned by Clair v4
						</li></ul></div></section><section class="section" id="clairv4-limitations"><div class="titlepage"><div><div><h3 class="title">3.1.5. Clair v4 limitations</h3></div></div></div><p>
					The following limitations are currently being addressed by the development team:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							As of Clair v4, both operating system level and programming language packages are covered. The latter is currently limited to Python, however support for other languages will be added in the future.
						</li><li class="listitem">
							There is currently limited multi-arch support on Clair v4, which works for package managers like <code class="literal">rpm</code>, <code class="literal">yum</code>, and <code class="literal">dnf</code> that compensates for differences in endianess.
						</li><li class="listitem">
							Clair v4 does not currently support MSFT Windows images.
						</li><li class="listitem">
							Clair v4 does not currently support slim/scratch container images.
						</li></ul></div></section><section class="section" id="clairv4-air-gapped"><div class="titlepage"><div><div><h3 class="title">3.1.6. Air-gapped Clair v4</h3></div></div></div><p>
					Red Hat Quay 3.4 and later and Clair v4 are supported in disconnected environments. By default, Clair v4 will attempt to run automated updates against Red Hat servers. When Clair v4 in network environments is disconnected from the internet:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The Clair v4 auto-update is disabled in the Clair <code class="literal">config</code> bundle.
						</li><li class="listitem">
							On a system with internet access, the vulnerability database updates is performed manually and exported to a disk.
						</li><li class="listitem">
							The on-disk data is then transferred to the target system with offline media. It is then manually imported.
						</li></ul></div></section></section></section><section class="chapter" id="content-distrib-intro"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Content distribution</h1></div></div></div><p>
			Content distribution features in Red Hat Quay include:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<a class="link" href="#mirroring-intro" title="4.1. Repository mirroring">Repository mirroring</a>
				</li><li class="listitem">
					<a class="link" href="#georepl-intro" title="4.2. Geo-replication">Geo-replication</a>
				</li><li class="listitem">
					<a class="link" href="#airgap-intro" title="4.4. Air-gapped / disconnected deployments">Deployment in air-gapped environments</a>
				</li></ul></div><section class="section" id="mirroring-intro"><div class="titlepage"><div><div><h2 class="title">4.1. Repository mirroring</h2></div></div></div><p>
				Red Hat Quay repository mirroring lets you mirror images from external container registries (or another local registry) into your Red Hat Quay cluster. Using repository mirroring, you can synchronize images to Red Hat Quay based on repository names and tags.
			</p><p>
				From your Red Hat Quay cluster with repository mirroring enabled, you can:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Choose a repository from an external registry to mirror
					</li><li class="listitem">
						Add credentials to access the external registry
					</li><li class="listitem">
						Identify specific container image repository names and tags to sync
					</li><li class="listitem">
						Set intervals at which a repository is synced
					</li><li class="listitem">
						Check the current state of synchronization
					</li></ul></div><p>
				To use the mirroring functionality, you need to:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Enable Repository Mirroring in the Red Hat Quay configuration
					</li><li class="listitem">
						Run a repository mirroring worker
					</li><li class="listitem">
						Create mirrored repositories
					</li></ul></div><p>
				All repository mirroring configuration can be performed using the configuration tool UI or via the Quay API
			</p><section class="section" id="mirroring-using"><div class="titlepage"><div><div><h3 class="title">4.1.1. Using repository mirroring</h3></div></div></div><p>
					Here are some features and limitations of Red Hat Quay repository mirroring:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							With repository mirroring, you can mirror an entire repository or selectively limit which images are synced. Filters can be based on a comma-separated list of tags, a range of tags, or other means of identifying tags through regular expressions.
						</li><li class="listitem">
							Once a repository is set as mirrored, you cannot manually add other images to that repository.
						</li><li class="listitem">
							Because the mirrored repository is based on the repository and tags you set, it will hold only the content represented by the repo/tag pair. In other words, if you change the tag so that some images in the repository no longer match, those images will be deleted.
						</li><li class="listitem">
							Only the designated robot can push images to a mirrored repository, superseding any role-based access control permissions set on the repository.
						</li><li class="listitem">
							With a mirrored repository, a user can pull images (given read permission) from the repository but not push images to the repository.
						</li><li class="listitem">
							Changing settings on your mirrored repository is done from the Mirrors tab on the Repositories page for the mirrored repository you create.
						</li><li class="listitem">
							Images are synced at set intervals, but can also be synced on demand.
						</li></ul></div></section><section class="section" id="mirroring-recommend"><div class="titlepage"><div><div><h3 class="title">4.1.2. Repository mirroring recommendations</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Repository mirroring pods can run on any node including other nodes where Quay is already running
						</li><li class="listitem">
							Repository mirroring is scheduled in the database and run in batches. As a result, more workers could mean faster mirroring, since more batches will be processed.
						</li><li class="listitem"><p class="simpara">
							The optimal number of mirroring pods depends on:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									The total number of repositories to be mirrored
								</li><li class="listitem">
									The number of images and tags in the repositories and the frequency of changes
								</li><li class="listitem">
									Parallel batches
								</li></ul></div></li><li class="listitem">
							You should balance your mirroring schedule across all mirrored repositories, so that they do not all start up at the same time.
						</li><li class="listitem">
							For a mid-size deployment, with approximately 1000 users and 1000 repositories, and with roughly 100 mirrored repositories, it is expected that you would use 3-5 mirroring pods, scaling up to 10 if required.
						</li></ul></div></section><section class="section" id="mirroring-events"><div class="titlepage"><div><div><h3 class="title">4.1.3. Event notifications for mirroring</h3></div></div></div><p>
					There are three notification events for repository mirroring:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Repository Mirror Started
						</li><li class="listitem">
							Repository Mirror Success
						</li><li class="listitem">
							Repository Mirror Unsuccessful
						</li></ul></div><p>
					The events can be configured inside the Settings tab for each repository, and all existing notification methods such as email, slack, Quay UI and webhooks are supported.
				</p></section><section class="section" id="mirroring-api-intro"><div class="titlepage"><div><div><h3 class="title">4.1.4. Mirroring API</h3></div></div></div><p>
					You can use the Quay API to configure repository mirroring:
				</p><p>
					<span class="inlinemediaobject"><img src="images/swagger-mirroring.png" alt="Mirroring API"/></span>
				</p><p>
					More information is available in the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html-single/red_hat_quay_api_guide/index">Red Hat Quay API Guide</a>
				</p></section></section><section class="section" id="georepl-intro"><div class="titlepage"><div><div><h2 class="title">4.2. Geo-replication</h2></div></div></div><p>
				Geo-replication allows multiple, geographically distributed Quay deployments to work as a single registry from the perspective of a client or user. It significantly improves push and pull performance in a globally-distributed Quay setup. Image data is asynchronously replicated in the background with transparent failover / redirect for clients.
			</p><section class="section" id="geo_replication_features"><div class="titlepage"><div><div><h3 class="title">4.2.1. Geo-replication features</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							When geo-replication is configured, container image pushes will be written to the preferred storage engine for that Red Hat Quay instance (typically the nearest storage backend within the region).
						</li><li class="listitem">
							After the initial push, image data will be replicated in the background to other storage engines.
						</li><li class="listitem">
							The list of replication locations is configurable and those can be different storage backends.
						</li><li class="listitem">
							An image pull will always use the closest available storage engine, to maximize pull performance.
						</li><li class="listitem">
							If replication hasn’t been completed yet, the pull will use the source storage backend instead.
						</li></ul></div></section><section class="section" id="georepl-prereqs"><div class="titlepage"><div><div><h3 class="title">4.2.2. Geo-replication requirements and constraints</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							A single database, and therefore all metadata and Quay configuration, is shared across all regions.
						</li><li class="listitem">
							A single Redis cache is shared across the entire Quay setup and needs to accessible by all Quay pods.
						</li><li class="listitem">
							The exact same configuration should be used across all regions, with exception of the storage backend, which can be configured explicitly using the <code class="literal">QUAY_DISTRIBUTED_STORAGE_PREFERENCE</code> environment variable.
						</li><li class="listitem">
							Geo-Replication requires object storage in each region. It does not work with local storage or NFS.
						</li><li class="listitem">
							Each region must be able to access every storage engine in each region (requires a network path).
						</li><li class="listitem">
							Alternatively, the storage proxy option can be used.
						</li><li class="listitem">
							The entire storage backend (all blobs) is replicated. This is in contrast to repository mirroring, which can be limited to an organization or repository or image.
						</li><li class="listitem">
							All Quay instances must share the same entrypoint, typically via load balancer.
						</li><li class="listitem">
							All Quay instances must have the same set of superusers, as they are defined inside the common configuration file.
						</li></ul></div><p>
					If the above requirements cannot be met, you should instead use two or more distinct Quay deployments and take advantage of repository mirroring functionality.
				</p></section><section class="section" id="georepl-arch"><div class="titlepage"><div><div><h3 class="title">4.2.3. Geo-replication architecture</h3></div></div></div><p>
					<span class="inlinemediaobject"><img src="images/georeplication-aws.png" alt="Georeplication"/></span>
				</p><p>
					In the example shown above, Quay is running in two separate regions, with a common database and a common Redis instance. Localized image storage is provided in each region and image pulls are served from the closest available storage engine. Container image pushes are written to the preferred storage engine for the Quay instance, and will then be replicated, in the background, to the other storage engines.
				</p><p>
					The following block diagram shows a possible distribution of resources where Quay has been deployed on two OpenShift clusters using the Operator:
				</p><p>
					<span class="inlinemediaobject"><img src="images/georeplication-arch.png" alt="Georeplication architecture"/></span>
				</p></section><section class="section" id="georepl-mixed-storage"><div class="titlepage"><div><div><h3 class="title">4.2.4. Mixed storage for geo-replication</h3></div></div></div><p>
					Quay geo-replication supports the use of different, and multiple, replication targets for example, using AWS S3 storage on public cloud and using Ceph storage on-prem. This complicates the key requirement of granting access to all storage backends from all Quay pods and cluster nodes. As a result, it is recommended that you:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Use a VPN to prevent visibility of the internal storage <span class="emphasis"><em>or</em></span>
						</li><li class="listitem">
							Use a token pair that only allows access to the specified bucket used by Quay
						</li></ul></div><p>
					This will result in the public cloud instance of Quay having access to on-prem storage but the network will be encrypted, protected, and will use ACLs, thereby meeting security requirements.
				</p><p>
					If you cannot implement these security measures, it may be preferable to deploy two distinct Quay registries and to use repository mirroring as an alternative to geo-replication.
				</p></section></section><section class="section" id="mirroring-versus-georepl"><div class="titlepage"><div><div><h2 class="title">4.3. Repository mirroring versus geo-replication</h2></div></div></div><p>
				Quay geo-replication mirrors the entire image storage backend data between 2 or more different storage backends while the database is shared (one Quay registry with two different blob storage endpoints). The primary use cases for geo-replication are:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Speeding up access to the binary blobs for geographically dispersed setups
					</li><li class="listitem">
						Guaranteeing that the image content is the same across regions
					</li></ul></div><p>
				Repository mirroring synchronizes selected repositories (or subsets of repositories) from one registry to another. The registries are distinct, with registry is separate database and image storage. The primary use cases for mirroring are:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Independent registry deployments in different datacenters or regions, where a certain subset of the overall content is supposed to be shared across the datacenters / regions
					</li><li class="listitem">
						Automatic synchronization or mirroring of selected (whitelisted) upstream repositories from external registries into a local Quay deployment
					</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Repository mirroring and geo-replication can be used simultaneously.
				</p></div></div><div class="table" id="idm45976349255040"><p class="title"><strong>Table 4.1. Red Hat Quay Repository mirroring versus geo-replication</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 33%; " class="col_1"/><col style="width: 33%; " class="col_2"/><col style="width: 33%; " class="col_3"/></colgroup><thead><tr><th align="left" valign="top" id="idm45976347485840" scope="col">Feature / Capability</th><th align="left" valign="top" id="idm45976347484976" scope="col">Geo-replication</th><th align="left" valign="top" id="idm45976347484112" scope="col">Repository mirroring</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm45976347485840">
							<p>
								What is the feature designed to do?
							</p>
							</td><td align="left" valign="top" headers="idm45976347484976">
							<p>
								A shared, global registry
							</p>
							</td><td align="left" valign="top" headers="idm45976347484112">
							<p>
								Distinct, different registries
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm45976347485840">
							<p>
								What happens if replication or mirroring hasn’t been completed yet?
							</p>
							</td><td align="left" valign="top" headers="idm45976347484976">
							<p>
								The remote copy is used (slower)
							</p>
							</td><td align="left" valign="top" headers="idm45976347484112">
							<p>
								No image is served
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm45976347485840">
							<p>
								Is access to all storage backends in both regions required?
							</p>
							</td><td align="left" valign="top" headers="idm45976347484976">
							<p>
								Yes (all Red Hat Quay nodes)
							</p>
							</td><td align="left" valign="top" headers="idm45976347484112">
							<p>
								No (distinct storage)
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm45976347485840">
							<p>
								Can users push images from both sites to the same repository?
							</p>
							</td><td align="left" valign="top" headers="idm45976347484976">
							<p>
								Yes
							</p>
							</td><td align="left" valign="top" headers="idm45976347484112">
							<p>
								No
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm45976347485840">
							<p>
								Is all registry content and configuration identical across all regions (shared database)
							</p>
							</td><td align="left" valign="top" headers="idm45976347484976">
							<p>
								Yes
							</p>
							</td><td align="left" valign="top" headers="idm45976347484112">
							<p>
								No
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm45976347485840">
							<p>
								Can users select individual namespaces or repositories to be mirrored?
							</p>
							</td><td align="left" valign="top" headers="idm45976347484976">
							<p>
								No,by default
							</p>
							</td><td align="left" valign="top" headers="idm45976347484112">
							<p>
								Yes
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm45976347485840">
							<p>
								Can users apply filters to synchronization rules?
							</p>
							</td><td align="left" valign="top" headers="idm45976347484976">
							<p>
								No
							</p>
							</td><td align="left" valign="top" headers="idm45976347484112">
							<p>
								Yes
							</p>
							</td></tr></tbody></table></div></div></section><section class="section" id="airgap-intro"><div class="titlepage"><div><div><h2 class="title">4.4. Air-gapped / disconnected deployments</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Quay and Clair connected to the internet, with an air-gapped OpenShift cluster accessing the Quay registry through an explicit, white-listed hole in the firewall
					</li><li class="listitem">
						Quay and Clair running inside the firewall, with image and CVE data transferred to the target system using offline media. The data is exported from a separate Quay and Clair deployment that is connected to the internet.
					</li></ul></div><p>
				<span class="inlinemediaobject"><img src="images/air-gap.png" alt="Air-gapped deployment"/></span>
			</p><section class="section" id="airgap-clair"><div class="titlepage"><div><div><h3 class="title">4.4.1. Using Clair in air-gapped environments</h3></div></div></div><p>
					By default, Clair will attempt to run automated updates against Red Hat servers. To run Clair in network environments that are disconnected from the internet:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Disable Clair auto-update in the Clair configuration bundle
						</li><li class="listitem">
							Manually update the vulnerability database on a system with internet access and then export to disk
						</li><li class="listitem">
							Transfer the on-disk data to the target system using offline media and then manually import it into Clair
						</li></ul></div><p>
					Using Clair in air-gapped environments is fully containerized and, as a result, is easy to automate.
				</p></section></section></section><section class="chapter" id="access-control-intro"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Access control</h1></div></div></div><p>
			Red Hat Quay provides both Role Based Access Control (RBAC) and Fine-Grained Access Control, and has team features that allow for limited access control of repositories, organizations, and user privileges. Red Hat Quay access control features also provide support for dispersed organizations.
		</p><p>
			<span class="inlinemediaobject"><img src="images/quay-tenancy-model.png" alt="Quay tenancy model"/></span>
		</p><section class="section" id="repository-organizations-and-users"><div class="titlepage"><div><div><h2 class="title">5.1. Repository organizations and users</h2></div></div></div><p>
				Red Hat Quay repository organizations provide a way to share repositories under a common namespace that does not belong to a single user. These organizations allow repositories to be used in a shared setting, for example, by a company.
			</p><p>
				The following is a brief overview of the organization’s main page:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						<span class="strong strong"><strong>Managing teams</strong></span>: used to manage teams within the organization
					</li><li class="listitem">
						<span class="strong strong"><strong>Creating a team</strong></span>: used to create a team within the organization
					</li><li class="listitem">
						<span class="strong strong"><strong>Team Global Permissions</strong></span>: used to define the global permissions of teams within an organization
					</li><li class="listitem">
						<span class="strong strong"><strong>Managing team members</strong></span>: used to manage teams within the organization.
					</li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Defined permissions</strong></span>:
					</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 50%; " class="col_2"/></colgroup><thead><tr><th align="left" valign="top" id="idm45976348951664" scope="col">Permission</th><th align="left" valign="top" id="idm45976348950800" scope="col">Abilities</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm45976348951664">
									<p>
										<span class="strong strong"><strong>Members</strong></span>
									</p>
									</td><td align="left" valign="top" headers="idm45976348950800">
									<p>
										Inherits all permissions sets for the team
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm45976348951664">
									<p>
										<span class="strong strong"><strong>Creator</strong></span>
									</p>
									</td><td align="left" valign="top" headers="idm45976348950800">
									<p>
										All member positions, plus the ability to create new repositories
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm45976348951664">
									<p>
										<span class="strong strong"><strong>Admin</strong></span>
									</p>
									</td><td align="left" valign="top" headers="idm45976348950800">
									<p>
										Full administrative access to the organization, including the ability to create news, add members, and set permissions.
									</p>
									</td></tr></tbody></table></div></li></ul></div><section class="section" id="quay-users"><div class="titlepage"><div><div><h3 class="title">5.1.1. Red Hat Quay users</h3></div></div></div><p>
					A new Red Hat Quay user can set up an account at www.quay.io. Usernames must be unique, and they cannot be changed once invited to an organization. After a user account is established, options to sign in via Google or GitHub can be added.
				</p><p>
					User accounts allow individuals to log in through the Red Hat Quay UI or a client, such as <code class="literal">docker login</code> or <code class="literal">podman login</code>.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Because <code class="literal">docker login</code> via the CLI stores passwords in plaintext, we recommend generating an encrypted version of the password.
					</p></div></div><p>
					Each user automatically gets their own user namespace, for example, quay.example.com/user/&lt;username&gt;.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						User namespaces are different from Quay organizations. There are no teams, usage logs, default permissions, or OAuth applications. By comparison, organizations are listed under quay.example.com/organization.
					</p></div></div><p>
					Users who are not members of an organization can be added to the repository and given permissions. External users are marked with a special character inside of the <span class="strong strong"><strong>Users and Robot Permissions</strong></span> section under the <span class="strong strong"><strong>Repository Settings</strong></span> tab. They are also shown under the <span class="strong strong"><strong>Collaborators View</strong></span> tab on on the organization level of the <span class="strong strong"><strong>Teams and Membership</strong></span> page.
				</p></section><section class="section" id="quay-robot-accounts"><div class="titlepage"><div><div><h3 class="title">5.1.2. Red Hat Quay robot accounts</h3></div></div></div><p>
					Robot accounts are named tokens that hold credentials for accessing external repositories. By assigning credentials to a robot, that robot can be used across multiple mirrored repositories that need to access the same external registry.
				</p><p>
					Robot accounts are managed inside of the <span class="strong strong"><strong>Robot Accounts</strong></span> tab. They can only belong to one organization, but can be assigned to multiple Teams.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Teams and users can belong to multiple organizations.
					</p></div></div><p>
					For more information on robot accounts, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_quay/3.5/html-single/manage_red_hat_quay/index#working-with-mirrored-repo">Working with mirrored repositories</a>.
				</p></section><section class="section" id="quay-super-users"><div class="titlepage"><div><div><h3 class="title">5.1.3. Red Hat Quay Super users</h3></div></div></div><p>
					<code class="literal">Super users</code> are a group of Red Hat Quay users with enhanced access and privileges, including:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Super user API calls that are not visible or accessible to normal users.
						</li><li class="listitem"><p class="simpara">
							Access to the <code class="literal">Super User Admin Panel</code>, which allows users to
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									Change a user’s email address, password, delete, or disable users.
								</li><li class="listitem">
									Rename, delete, or take ownership of an organization.
								</li><li class="listitem">
									Change expiration time, rename, or delete service keys such as Clair.
								</li><li class="listitem">
									Access to global and registry-wide usage, or audit, logs.
								</li><li class="listitem">
									Create and send globally visible user messages.
								</li></ul></div></li></ul></div><p>
					Primary super users are created during the initial Red Hat Quay configuration, and more can be created after configuration is complete.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Super users cannot delete repositories or organizations without taking ownership of them first.
					</p></div></div></section></section><section class="section" id="permissions"><div class="titlepage"><div><div><h2 class="title">5.2. Permissions</h2></div></div></div><p>
				Organizations are organized into a set of Teams and can provide access to a subset of the repositories under that namespace. Permissions for users within an organization can be set for individuals, teams, and robot accounts.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Permissions are only applied to new users and teams when a new repository is created.
				</p></div></div><section class="section" id="role-based-access-control"><div class="titlepage"><div><div><h3 class="title">5.2.1. Role Based Access Control (RBAC)</h3></div></div></div><p>
					Red Hat Quay offers three types of permissions:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">Read</code>, which allows users, robots, and teams to pull images.
						</li><li class="listitem">
							<code class="literal">Write</code>, which allows users, robots, and teams to push images.
						</li><li class="listitem">
							<code class="literal">Admin</code>, which provides users, robots, and teams with administrative privileges.
						</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Administrative users can delegate new permissions for existing users and teams, change existing permissions, and revoke permissions when necessary
					</p></div></div><p>
					Permissions can be delegated across the entire organization and on specific repositories. For example, <code class="literal">Read</code> permissions can be set to a specific team within the organization, while <code class="literal">Admin</code> permissions can be given to all users across all repositories within the organization.
				</p></section><section class="section" id="fine-grained-access-control"><div class="titlepage"><div><div><h3 class="title">5.2.2. Fine Grained Access Control</h3></div></div></div><p>
					Red Hat Quay allow users to integrate their existing identity infrastructure and use a fine-grained permissions system to map their organizational structure and grant access to whole teams to manage specific repositories.
				</p><p>
					Red Hat Quay is supported by the following authentication providers:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Built-in Database Authentication
						</li><li class="listitem">
							Lightweight Directory Access Protocol (LDAP) authentication and _sync
						</li><li class="listitem">
							External OpenID Connect (OIDC) provider
						</li><li class="listitem">
							OpenStack Keystone
						</li></ul></div><section class="section" id="ldap-binding-groups"><div class="titlepage"><div><div><h4 class="title">5.2.2.1. Bind team membership to specific LDAP groups</h4></div></div></div><p>
						With Red Hat Quay, team sync support can be enabled via the config application by clicking on the <code class="literal">Enable team synchronization support</code> button once Lightweight Directory Access Protocol (LDAP) is selected as the internal authentication method:
					</p><p>
						<span class="inlinemediaobject"><img src="images/ldap-internal-authentication.png" alt="LDAP authentication"/></span>
					</p><p>
						The default time to sync groups is 60 minutes, but can be modified to any other time frame if needed. The first sync happens immediately after linking a team to a specific group. The last option enables any team admin, and not just super users, to sync groups.
					</p><p>
						In order to enable team sync, users must configure their teams by clicking on the <code class="literal">Enable Directory Synchronization</code> button in the <span class="strong strong"><strong>Teams</strong></span> tab. A distinguished name is required relative to the base DN. For example:
					</p><pre class="screen">cn=quayusers,ou=cloud</pre><p>
						If binding to the group goes correctly, Red Hat Quay will display the group’s distinguished name and the "last updated" status on the page.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Once sync is enabled, adding users to the group is no longer possible. It becomes read only.
						</p></div></div><p>
						Users that are added to the LDAP group will automatically be added to the team as well. Robot accounts can still be added to the group directly.
					</p></section><section class="section" id="ldap-filtering"><div class="titlepage"><div><div><h4 class="title">5.2.2.2. LDAP filtering</h4></div></div></div><p>
						Lightweight Directory Access Protocol (LDAP) is an open, vendor neutral, industry standard application protocol for accessing and maintaining distributed directory information services over an IP network. Red Hat Quay supports using LDAP as an identity provider. Red Hat Quay users can now apply additional filters for lookup queries if (LDAP) / AD authentication is used. For information on setting up LDAP authentication for Red Hat Quay, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_quay/3.5/html/manage_red_hat_quay/ldap-authentication-setup-for-quay-enterprise">LDAP authentication setup for Red Hat Quay</a>.
					</p></section><section class="section" id="quay-sso-keycloak"><div class="titlepage"><div><div><h4 class="title">5.2.2.3. Red Hat Quay and Red Hat SSO / Keycloak</h4></div></div></div><p>
						Quay Enterprise can support authentication via OpenID Connect (OIDC). Red Hat Single Sign On (SSO) is an OIDC provider that allows administrators to have a seamless authentication integration between Quay Enterprise and other application platforms such as Red Hat OpenShift Container Platform.
					</p><p>
						Red Hat Quay and Red Hat SSO / Keycloak requires that TLS/SSL is properly configured to proceed with setup. Red Hat SSO supports many different types of OIDC. Quay Enterprise, however, only supports OIDC clients configured for <a class="link" href="https://access.redhat.com/solutions/3496181">Confidential Client Credentials</a>. For more information configuring Red Hat SSO, see <a class="link" href="https://access.redhat.com/solutions/3566061">Quay Enterprise with Red Hat Single Sign On / Keycloak</a>.
					</p></section></section></section></section><section class="chapter" id="sizing-intro"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Sizing</h1></div></div></div><p>
			Scalability of Red Hat Quay is one of its key strengths. With Red Hat Quay, a typical mid-size deployment of approximately 2,000 users can serve content to thousands of kubernetes clusters world-wide through Quay.io.
		</p><p>
			Since sizing heavily depends on a multitude of factors, such as the number of users, images, concurrent pulls and pushes, etc., there are no standard sizing recommendations.
		</p><p>
			Stateless components of Red Hat Quay can be scaled out. This will cause a heavier load on backend services.
		</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
				Scaling out stateless components will add heavier loads to stateful components.
			</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
				Auto-scaling on k8s deployments is currently in development, and will be implemented in a future version of the Quay operator.
			</p></div></div><p>
			The following are the minimum requirements for systems running Red Hat Quay (per container/pod instance):
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<span class="strong strong"><strong>Quay</strong></span>: minimum 6GB; recommended 8GB + swap, 2 more more vCPUs
				</li><li class="listitem">
					<span class="strong strong"><strong>Clair</strong></span>: recommended 2GB RAM + sqap, 2 or more vCPUs
				</li><li class="listitem">
					<span class="strong strong"><strong>Storage</strong></span>: recommended 30GB
				</li><li class="listitem">
					<span class="strong strong"><strong>NooBaa</strong></span>: minimum 2GB, 1 vCPU (when <code class="literal">objectstorage</code> component is selected via the Operator)
				</li><li class="listitem">
					Clair database requirements for security metadata: minimum 200MB
				</li></ul></div><section class="section" id="quay-sample-sizings-intro"><div class="titlepage"><div><div><h2 class="title">6.1. Red Hat Quay Sample Sizings</h2></div></div></div><p>
				The following is a sample sizing of an existing Red Hat Quay deployment. Whether a deployment runs appropriately with the same metrics will depend on many other factors not shown below.
			</p><p>
				<span class="inlinemediaobject"><img src="images/quay-sample-sizing.png" alt="Red Hat Quay Sample Size"/></span>
			</p></section><section class="section" id="sample-quay-on-prem-intro"><div class="titlepage"><div><div><h2 class="title">6.2. Sample Red Hat Quay on-premises configuration</h2></div></div></div><p>
				The following images shows an example on-premises configuration.
			</p><p>
				<span class="inlinemediaobject"><img src="images/sample-on-prem.png" alt="On-prem sample configuration"/></span>
			</p></section><section class="section" id="quay-subscription-intro"><div class="titlepage"><div><div><h2 class="title">6.3. Red Hat Quay subscription information</h2></div></div></div><p>
				Red Hat Quay is available with Standard or Premium support, and subscriptions are based on deployments.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Deployment means an installation of a single Red Hat Quay registry using a shared data backend.
				</p></div></div><p>
				With a Red Hat Quay subscription
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						there is no limit on the number of pods (Quay, Clair, Builder, etc.) a user can create.
					</li><li class="listitem">
						Quay pods can run in multiple data centers/availability zones.
					</li><li class="listitem">
						multiple storage backends and database backends can be run, so long as it is one shared storage backend and one shared database backend.
					</li><li class="listitem">
						users can manage content for a single cluster or thousands of clusters.
					</li><li class="listitem">
						access to clusters or datacenters is not dependent on a user’s physical location.
					</li><li class="listitem">
						users have access to CSO and the Quay Bridge Operator at no additional cost.
					</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Red Hat Quay geo-replication requires a subscription for each storage replication. The database, however, is shared.
				</p></div></div><p>
				For more information on purchasing a Red Hat Quay subscription, see <a class="link" href="https://www.redhat.com/en/technologies/cloud-computing/quay">Red Hat Quay</a>.
			</p></section><section class="section" id="quay-example-deployment"><div class="titlepage"><div><div><h2 class="title">6.4. Red Hat Quay example deployments</h2></div></div></div><p>
				The following images show two Red Hat Quay example deployments:
			</p><p>
				<span class="inlinemediaobject"><img src="images/quay-deployment-example-one.png" alt="Red Hat Quay deployment example"/></span>
			</p><p>
				<span class="inlinemediaobject"><img src="images/quay-deployment-example-two.png" alt="Red Hat Quay deployment example"/></span>
			</p></section><section class="section" id="quay-internal-registry-intro"><div class="titlepage"><div><div><h2 class="title">6.5. Using Red Hat Quay with or without internal registry</h2></div></div></div><p>
				Red Hat Quay can be used as an external registry in front of multiple OpenShift clusters with their internal registries.
			</p><p>
				Red Hat Quay can also be used in place of using the internal registry when it comes to automating builds and deployment rollouts. The required coordination of <code class="literal">Secrets</code> and <code class="literal">ImageStreams</code> is automated by the Quay Bridge Operator, which can be launched from the Operatorhub of OpenShift.
			</p></section><section class="section" id="quay-deployment-topology"><div class="titlepage"><div><div><h2 class="title">6.6. Red Hat Quay deployment topology</h2></div></div></div><p>
				The following image provides a high level overview of a Red Hat Quay deployment topology.
			</p><p>
				<span class="inlinemediaobject"><img src="images/quay-deployment-topology.png" alt="Red Hat Quay deployment topology"/></span>
			</p><p>
				In this deployment, all pushes, UI, and API requests come in via public Quay endpoints. Pulls are served directly from <code class="literal">object storage</code>.
			</p></section><section class="section" id="quay-deployment-topology-with-storage-proxy"><div class="titlepage"><div><div><h2 class="title">6.7. Red Hat Quay deployment topology with storage proxy</h2></div></div></div><p>
				The following image provides a high level overview of a Red Hat Quay deployment topology with storage proxy configured.
			</p><p>
				<span class="inlinemediaobject"><img src="images/quay-deployment-topology-storage-proxy.png" alt="Red Hat Quay deployment topology with storage proxy"/></span>
			</p><p>
				With storage proxy configured, all traffic passes through the public Quay endpoint.
			</p></section></section><section class="chapter" id="scalability-intro"><div class="titlepage"><div><div><h1 class="title">Chapter 7. Scalability</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					Massive scale testing Quay.io
				</li><li class="listitem">
					Real-time garbage collection
				</li><li class="listitem">
					Automated squashing
				</li></ul></div></section><section class="chapter" id="build-automation-intro"><div class="titlepage"><div><div><h1 class="title">Chapter 8. Build automation</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					Seamless Git integration
				</li><li class="listitem">
					Build workers
				</li><li class="listitem">
					Webhooks
				</li></ul></div></section><section class="chapter" id="integration-intro"><div class="titlepage"><div><div><h1 class="title">Chapter 9. Integration</h1></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					Extensible API
				</li><li class="listitem">
					Webhooks, OAuth
				</li><li class="listitem">
					Robot Accounts
				</li></ul></div></section><div><div xml:lang="en-US" class="legalnotice" id="idm45976349527728"><h1 class="legalnotice">Legal Notice</h1><div class="para">
		Copyright <span class="trademark"/>© 2021 Red Hat, Inc.
	</div><div class="para">
		The text of and illustrations in this document are licensed by Red Hat under a Creative Commons Attribution–Share Alike 3.0 Unported license ("CC-BY-SA"). An explanation of CC-BY-SA is available at <a class="uri" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a>. In accordance with CC-BY-SA, if you distribute this document or an adaptation of it, you must provide the URL for the original version.
	</div><div class="para">
		Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law.
	</div><div class="para">
		Red Hat, Red Hat Enterprise Linux, the Shadowman logo, the Red Hat logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Linux</span>® is the registered trademark of Linus Torvalds in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Java</span>® is a registered trademark of Oracle and/or its affiliates.
	</div><div class="para">
		<span class="trademark">XFS</span>® is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries.
	</div><div class="para">
		<span class="trademark">MySQL</span>® is a registered trademark of MySQL AB in the United States, the European Union and other countries.
	</div><div class="para">
		<span class="trademark">Node.js</span>® is an official trademark of Joyent. Red Hat is not formally related to or endorsed by the official Joyent Node.js open source or commercial project.
	</div><div class="para">
		The <span class="trademark">OpenStack</span>® Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community.
	</div><div class="para">
		All other trademarks are the property of their respective owners.
	</div></div></div></div></div></div><script type="text/javascript">
                        jQuery(document).ready(function() {
                            initSwitchery();
                            jQuery('pre[class*="language-"]').each(function(i, block){hljs.highlightBlock(block);});
                        });
                    </script></body></html>